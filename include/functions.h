#ifndef FUNCTIONS_H
#define FUNCTIONS_H

#include "z64.h"

void bootproc(void);
void ViConfig_UpdateVi(u32 black);
void ViConfig_UpdateBlack(void);
s32 DmaMgr_DmaRomToRam(uintptr_t rom, void* ram, size_t size);
s32 DmaMgr_DmaHandler(OSPiHandle* pihandle, OSIoMesg* mb, s32 direction);
DmaEntry* DmaMgr_FindDmaEntry(uintptr_t vrom);
u32 DmaMgr_TranslateVromToRom(uintptr_t vrom);
s32 DmaMgr_FindDmaIndex(uintptr_t vrom);
const char* func_800809F4(uintptr_t param_1);
void DmaMgr_ProcessMsg(DmaRequest* req);
void DmaMgr_ThreadEntry(void* arg);
s32 DmaMgr_SendRequestImpl(DmaRequest* request, void* vramStart, uintptr_t vromStart, size_t size, UNK_TYPE4 unused, OSMesgQueue* queue, void* msg);
s32 DmaMgr_SendRequest0(void* vramStart, uintptr_t vromStart, size_t size);
void DmaMgr_Start(void);
void DmaMgr_Stop(void);
void* Yaz0_FirstDMA(void);
void* Yaz0_NextDMA(void* curSrcPos);
s32 Yaz0_DecompressImpl(u8* src, u8* dst);
void Yaz0_Decompress(uintptr_t romStart, void* dst, size_t size);
void IrqMgr_AddClient(IrqMgr* irqmgr, IrqMgrClient* client, OSMesgQueue* msgQueue);
void IrqMgr_RemoveClient(IrqMgr* irqmgr, IrqMgrClient* remove);
void IrqMgr_SendMesgForClient(IrqMgr* irqmgr, OSMesg msg);
void IrqMgr_JamMesgForClient(IrqMgr* irqmgr, OSMesg msg);
void IrqMgr_HandlePreNMI(IrqMgr* irqmgr);
void IrqMgr_CheckStack(void);
void IrqMgr_HandlePRENMI450(IrqMgr* irqmgr);
void IrqMgr_HandlePRENMI480(IrqMgr* irqmgr);
void IrqMgr_HandlePRENMI500(IrqMgr* irqmgr);
void IrqMgr_HandleRetrace(IrqMgr* irqmgr);
void IrqMgr_ThreadEntry(IrqMgr* irqmgr);
void IrqMgr_Init(IrqMgr* irqmgr, void* stack, OSPri pri, u8 retraceCount);

void osSyncPrintfUnused(const char* fmt, ...);

void rmonPrintf(const char* fmt, ...);

void RcpUtils_PrintRegisterStatus(void);
void RcpUtils_Reset(void);

void PadUtils_Init(Input* input);
void func_80085150(void);
void PadUtils_ResetPressRel(Input* input);
u32 PadUtils_CheckCurExact(Input* input, u16 value);
u32 PadUtils_CheckCur(Input* input, u16 key);
u32 PadUtils_CheckPressed(Input* input, u16 key);
u32 PadUtils_CheckReleased(Input* input, u16 key);
u16 PadUtils_GetCurButton(Input* input);
u16 PadUtils_GetPressButton(Input* input);
s8 PadUtils_GetCurX(Input* input);
s8 PadUtils_GetCurY(Input* input);
void PadUtils_SetRelXY(Input* input, s32 x, s32 y);
s8 PadUtils_GetRelXImpl(Input* input);
s8 PadUtils_GetRelYImpl(Input* input);
s8 PadUtils_GetRelX(Input* input);
s8 PadUtils_GetRelY(Input* input);
void PadUtils_UpdateRelXY(Input* input);

void MtxConv_F2L(Mtx* mtx, MtxF* mf);
void MtxConv_L2F(MtxF* mtx, Mtx* mf);

s32 func_80086620(OSMesgQueue* param_1, PadMgr* param_2, OSContStatus* param_3);

u32 Rand_Next(void);
void Rand_Seed(u32 seed);
f32 Rand_ZeroOne(void);
f32 Rand_Centered(void);
void Rand_Seed_Variable(u32* rndNum, u32 seed);
u32 Rand_Next_Variable(u32* rndNum);
f32 Rand_ZeroOne_Variable(u32* rndNum);
f32 Rand_Centered_Variable(u32* rndNum);

s32 PrintUtils_VPrintf(PrintCallback* pfn, const char* fmt, va_list args);
s32 PrintUtils_Printf(PrintCallback* pfn, const char* fmt, ...);
void Sleep_Cycles(OSTime time);
void Sleep_Nsec(u32 nsec);
void Sleep_Usec(u32 usec);
void Sleep_Msec(u32 ms);
void Sleep_Sec(u32 sec);

f32 fmodf(f32 dividend, f32 divisor);
void* __osMemset(void* ptr, s32 val, size_t size);
s32 __osStrcmp(const char* str1, const char* str2);
char* __osStrcpy(char* dst, const char* src);
void* __osMemcpy(void* dst, void* src, size_t size);

// void EnItem00_SetObject(EnItem00* this, PlayState* play, f32* shadowOffset, f32* shadowScale);
// void EnItem00_Init(Actor* thisx, PlayState* play);
// void EnItem00_Destroy(Actor* thisx, PlayState* play);
// void EnItem00_WaitForHeartObject(EnItem00* this, PlayState* play);
// void func_800A640C(EnItem00* this, PlayState* play);
// void func_800A6650(EnItem00* this, PlayState* play);
// void func_800A6780(EnItem00* this, PlayState* play);
// void func_800A6A40(EnItem00* this, PlayState* play);
// void EnItem00_Update(Actor* thisx, PlayState* play);
// void EnItem00_Draw(Actor* thisx, PlayState* play);
// void EnItem00_DrawRupee(EnItem00* this, PlayState* play);
// void EnItem00_DrawSprite(EnItem00* this, PlayState* play);
// void EnItem00_DrawHeartContainer(EnItem00* this, PlayState* play);
// void EnItem00_DrawHeartPiece(EnItem00* this, PlayState* play);
// s16 func_800A7650(s16 dropId);
Actor* Item_DropCollectible(PlayState* play, Vec3f* spawnPos, u32 params);
Actor* Item_DropCollectible2(PlayState* play, Vec3f* spawnPos, s32 params);
void Item_DropCollectibleRandom(PlayState* play, Actor* fromActor, Vec3f* spawnPos, s16 params);
s32 func_800A8150(s32 index);
s32 func_800A817C(s32 index);
s32 Item_CanDropBigFairy(PlayState* play, s32 index, s32 collectibleFlag);
void EffectBlure_AddVertex(EffectBlure* this, Vec3f* p1, Vec3f* p2);
void EffectBlure_AddSpace(EffectBlure* this);
void EffectBlure_Init1(void* thisx, void* initParamsx);
void EffectBlure_Init2(void* thisx, void* initParamsx);
void EffectBlure_Destroy(void* thisx);
s32 EffectBlure_Update(void* thisx);
void EffectBlure_Draw(void* thisx, GraphicsContext* gfxCtx);
void EffectShieldParticle_Init(void* thisx, void* initParamsx);
void EffectShieldParticle_Destroy(void* thisx);
s32 EffectShieldParticle_Update(void* thisx);
void EffectShieldParticle_Draw(void* thisx, GraphicsContext* gfxCtx);
void EffectSpark_Init(void* thisx, void* initParamsx);
void EffectSpark_Destroy(void* thisx);
s32 EffectSpark_Update(void* thisx);
void EffectSpark_Draw(void* thisx, GraphicsContext* gfxCtx);
void func_800AE2A0(PlayState* play, Color_RGBA8* color, s16 arg2, s16 arg3);
void func_800AE434(PlayState* play, Color_RGBA8* color, s16 arg2, s16 arg3);
void func_800AE5A0(PlayState* play);
void func_800AE5E4(PlayState* play, Color_RGBA8* color, s16 arg2, s16 arg3);
void func_800AE778(PlayState* play, Color_RGBA8* color, s16 arg2, s16 arg3);
void func_800AE8EC(PlayState* play);
void func_800AE930(CollisionContext* colCtx, EffectTireMark* this, Vec3f* pos, f32 arg3, s16 angle, CollisionPoly* colPoly, s32 bgId);
void func_800AEF44(EffectTireMark* this);
void EffectTireMark_Init(void* thisx, void* initParamsx);
void EffectTireMark_Destroy(void* thisx);
s32 EffectTireMark_Update(void* thisx);
void EffectTireMark_Draw(void* thisx, GraphicsContext* gfxCtx);
PlayState* Effect_GetPlayState(void);
void* Effect_GetByIndex(s32 index);
void Effect_Init(PlayState* play);
void Effect_Add(PlayState* play, s32* pIndex, s32 type, u8 arg3, u8 arg4, void* initParams);
void Effect_DrawAll(GraphicsContext* gfxCtx);
void Effect_UpdateAll(PlayState* play);
void Effect_Destroy(PlayState* play, s32 index);
void Effect_DestroyAll(PlayState* play);
void EffectSS_Init(PlayState* play, s32 numEntries);
void EffectSS_Clear(PlayState* play);
EffectSs* EffectSS_GetTable(void);
void EffectSS_Delete(EffectSs* effectSs);
void EffectSS_ResetEntry(EffectSs* particle);
s32 EffectSS_FindFreeSpace(s32 priority, s32* tableEntry);
void EffectSS_Copy(PlayState* play, EffectSs* effectsSs);
void EffectSs_Spawn(PlayState* play, s32 type, s32 priority, void* initData);
void EffectSS_UpdateParticle(PlayState* play, s32 index);
void EffectSS_UpdateAllParticles(PlayState* play);
void EffectSS_DrawParticle(PlayState* play, s32 index);
void EffectSS_DrawAllParticles(PlayState* play);
s16 func_800B096C(s16 arg0, s16 arg1, s32 arg2);
s16 func_800B09D0(s16 arg0, s16 arg1, f32 arg2);
u8 func_800B0A24(u8 arg0, u8 arg1, f32 arg2);
void EffectSs_DrawGEffect(PlayState* play, EffectSs* this, void* texture);
void EffectSsDust_Spawn(PlayState* play, u16 drawFlags, Vec3f* pos, Vec3f* velocity, Vec3f* accel, Color_RGBA8* primColor, Color_RGBA8* envColor, s16 scale, s16 scaleStep, s16 life, u8 updateMode);
void func_800B0DE0(PlayState* play, Vec3f* pos, Vec3f* velocity, Vec3f* accel, Color_RGBA8* primColor, Color_RGBA8* envColor, s16 scale, s16 scaleStep);
void func_800B0E48(PlayState* play, Vec3f* pos, Vec3f* velocity, Vec3f* accel, Color_RGBA8* primColor, Color_RGBA8* envColor, s16 scale, s16 scaleStep);
void func_800B0EB0(PlayState* play, Vec3f* pos, Vec3f* velocity, Vec3f* accel, Color_RGBA8* primColor, Color_RGBA8* envColor, s16 scale, s16 scaleStep, s16 life);
void func_800B0F18(PlayState* play, Vec3f* pos, Vec3f* velocity, Vec3f* accel, Color_RGBA8* primColor, Color_RGBA8* envColor, s16 scale, s16 scaleStep, s16 life);
void func_800B0F80(PlayState* play, Vec3f* pos, Vec3f* velocity, Vec3f* accel, Color_RGBA8* primColor, Color_RGBA8* envColor, s16 scale, s16 scaleStep, s16 life);
void func_800B0FE8(PlayState* play, Vec3f* pos, Vec3f* velocity, Vec3f* accel, Color_RGBA8* primColor, Color_RGBA8* envColor, s16 scale, s16 scaleStep);
void func_800B1054(PlayState* play, Vec3f* pos, Vec3f* velocity, Vec3f* accel, Color_RGBA8* primColor, Color_RGBA8* envColor, s16 scale, s16 scaleStep);
void func_800B10C0(PlayState* play, Vec3f* pos, Vec3f* velocity, Vec3f* accel);
void func_800B1130(PlayState* play, Vec3f* pos, Vec3f* velocity, Vec3f* accel);
void func_800B11A0(PlayState* play, Vec3f* pos, Vec3f* velocity, Vec3f* accel, s16 scale, s16 scaleStep);
void func_800B1210(PlayState* play, Vec3f* pos, Vec3f* velocity, Vec3f* accel, s16 scale, s16 scaleStep);
void func_800B1280(PlayState* play, Vec3f* pos, Vec3f* velocity, Vec3f* accel, s16 scale, s16 scaleStep, s16 life);
void func_800B12F0(PlayState* play, Vec3f* pos, Vec3f* velocity, Vec3f* accel, s16 scale, s16 scaleStep, s16 life);
void func_800B1360(PlayState* play, Vec3f* pos, Vec3f* velocity, Vec3f* accel, Color_RGBA8* primColor, Color_RGBA8* envColor);
void func_800B139C(PlayState* play, Vec3f* pos, Vec3f* velocity, Vec3f* accel, Color_RGBA8* primColor, Color_RGBA8* envColor);
void func_800B13D8(Vec3f* srcPos, f32 randScale, Vec3f* newPos, Vec3f* velocity, Vec3f* accel);
void func_800B14D4(PlayState* play, f32 randScale, Vec3f* srcPos);
void func_800B1598(PlayState* play, f32 randScale, Vec3f* srcPos);
void EffectSsKirakira_SpawnSmallYellow(PlayState* play, Vec3f* pos, Vec3f* velocity, Vec3f* accel);
void EffectSsKirakira_SpawnSmall(PlayState* play, Vec3f* pos, Vec3f* velocity, Vec3f* accel, Color_RGBA8* primColor, Color_RGBA8* envColor);
void EffectSsGSpk_SpawnSmall(PlayState* play, Actor* actor, Vec3f* pos, Vec3f* velocity, Vec3f* accel, Color_RGBA8* primColor, Color_RGBA8* envColor);
void EffectSsKirakira_SpawnDispersed(PlayState* play, Vec3f* pos, Vec3f* velocity, Vec3f* accel, Color_RGBA8* primColor, Color_RGBA8* envColor, s16 scale, s32 life);
// void EffectSsKirakira_SpawnFocused(UNK_TYPE1 param_1, UNK_TYPE1 param_2, UNK_TYPE1 param_3, UNK_TYPE1 param_4, UNK_TYPE4 param_5, UNK_TYPE4 param_6, UNK_TYPE2 param_7, UNK_TYPE4 param_8);
// void EffectSsBomb2_SpawnFade(UNK_TYPE4 uParm1, Vec3f* pzParm2, Vec3f* pzParm3, Vec3f* pzParm4);
void EffectSsBomb2_SpawnLayered(PlayState* play, Vec3f* pos, Vec3f* velocity, Vec3f* accel, s16 scale, s16 scaleStep);
// void EffectSsBlast_Spawn(UNK_TYPE4 uParm1, Vec3f* pzParm2, Vec3f* pzParm3, Vec3f* pzParm4, Color_RGBA8* param_5, Color_RGBA8* param_6, UNK_TYPE2 param_7, UNK_TYPE2 param_8, UNK_TYPE2 param_9, UNK_TYPE2 param_10);
void EffectSsBlast_SpawnWhiteCustomScale(PlayState* play, Vec3f* pos, Vec3f* velocity, Vec3f* accel, s16 scale, s16 scaleStep, s16 life);
// void EffectSsBlast_SpawnShockwave(UNK_TYPE1 param_1, UNK_TYPE1 param_2, UNK_TYPE1 param_3, UNK_TYPE1 param_4, UNK_TYPE4 param_5, UNK_TYPE4 param_6, UNK_TYPE2 param_7);
void EffectSsBlast_SpawnWhiteShockwave(PlayState* play, Vec3f* pos, Vec3f* velocity, Vec3f* accel);
// void EffectSsGSpk_SpawnAccel(UNK_TYPE4 uParm1, UNK_TYPE4 uParm2, Vec3f* pzParm3, Vec3f* pzParm4, Vec3f* param_5, Color_RGBA8* param_6, Color_RGBA8* param_7, UNK_TYPE2 param_8, UNK_TYPE2 param_9);
// void EffectSsGSpk_SpawnNoAccel(UNK_TYPE1 param_1, UNK_TYPE1 param_2, UNK_TYPE1 param_3, UNK_TYPE1 param_4, UNK_TYPE4 param_5, UNK_TYPE4 param_6, UNK_TYPE4 param_7, UNK_TYPE2 param_8, UNK_TYPE2 param_9);
void EffectSsGSpk_SpawnFuse(PlayState* play, Actor* actor, Vec3f* pos, Vec3f* velocity, Vec3f* accel);
// void EffectSsGSpk_SpawnRandColor(UNK_TYPE1 param_1, UNK_TYPE1 param_2, UNK_TYPE1 param_3, UNK_TYPE1 param_4, UNK_TYPE4 param_5, UNK_TYPE2 param_6, UNK_TYPE2 param_7);
// void EffectSsGSpk_SpawnSmall(UNK_TYPE1 param_1, UNK_TYPE1 param_2, UNK_TYPE1 param_3, UNK_TYPE1 param_4, UNK_TYPE4 param_5, UNK_TYPE4 param_6, UNK_TYPE4 param_7);
void EffectSsDFire_Spawn(PlayState* play, Vec3f* pos, Vec3f* velocity, Vec3f* accel, s16 scale, s16 scaleStep, s16 alpha, s16 alphaStep, s16 fadeDelay, s32 life);
void EffectSsBubble_Spawn(PlayState* play, Vec3f* pos, f32 yPosOffset, f32 yPosRandScale, f32 xzPosRandScale, f32 scale);
void EffectSsGRipple_Spawn(PlayState* play, Vec3f* pos, s16 radius, s16 radiusMax, s16 life);
void EffectSsGSplash_Spawn(PlayState* play, Vec3f* pos, Color_RGBA8* primColor, Color_RGBA8* envColor, s16 type, s16 scale);
void EffectSsGFire_Spawn(PlayState* play, Vec3f* pos);
// void EffectSsLightning_Spawn(UNK_TYPE4 uParm1, Vec3f* pzParm2, Color_RGBA8* pzParm3, Color_RGBA8* pzParm4, UNK_TYPE2 param_5, UNK_TYPE2 param_6, UNK_TYPE2 param_7, UNK_TYPE2 param_8);
void EffectSsDtBubble_SpawnColorProfile(PlayState* play, Vec3f* pos, Vec3f* velocity, Vec3f* accel, s16 scale, s16 life, s16 colorProfile, s16 randXZ);
void EffectSsDtBubble_SpawnCustomColor(PlayState* play, Vec3f* pos, Vec3f* velocity, Vec3f* accel, Color_RGBA8* primColor, Color_RGBA8* envColor, s16 scale, s16 life, s16 randXZ);
void EffectSsHahen_Spawn(PlayState* play, Vec3f* pos, Vec3f* velocity, Vec3f* accel, s16 flags, s16 scale, s16 objectId, s16 life, Gfx* dList);
void EffectSsHahen_SpawnBurst(PlayState* play, Vec3f* pos, f32 burstScale, s16 flags, s16 scale, s16 randScaleRange, s16 count, s16 objectId, s16 life, Gfx* dList);
// void func_800B2364(void);
void EffectSsStick_Spawn(PlayState* play, Vec3f* pos, s16 yaw);
// void EffectSsSibuki_Spawn(UNK_TYPE1 param_1, UNK_TYPE1 param_2, UNK_TYPE1 param_3, UNK_TYPE1 param_4, UNK_TYPE2 param_5, UNK_TYPE2 param_6, UNK_TYPE2 param_7);
void EffectSsSibuki_SpawnBurst(PlayState* play, Vec3f* pos);
void EffectSsStone1_Spawn(PlayState* play, Vec3f* pos, s32 reg0);
void EffectSsHitmark_SpawnFixedScale(PlayState* play, s32 type, Vec3f* pos);
void EffectSsHitmark_SpawnCustomScale(PlayState* play, s32 type, s16 scale, Vec3f* pos);
void EffectSsFhgFlash_SpawnShock(PlayState* play, Actor* actor, Vec3f* pos, s16 scale, u8 params);
void EffectSsKFire_Spawn(PlayState* play, Vec3f* pos, Vec3f* velocity, Vec3f* accel, s16 scaleMax, u8 type);
void EffectSsSolderSrchBall_Spawn(PlayState* play, Vec3f* pos, Vec3f* velocity, Vec3f* accel, s16 scale, s16* playerDetected, s16 flags);
void EffectSsKakera_Spawn(PlayState* play, Vec3f* pos, Vec3f* velocity, Vec3f* arg3, s16 gravity, s16 arg5, s16 arg6, s16 arg7, s16 arg8, s16 scale, s16 arg10, s16 arg11, s32 life, s16 colorIdx, s16 objectId, Gfx* dList);
// void EffectSsIcePiece_Spawn(UNK_TYPE4 uParm1, Vec3f* pzParm2, UNK_TYPE4 uParm3, Vec3f* pzParm4, Vec3f* param_5, UNK_TYPE4 param_6);
void EffectSsIcePiece_SpawnBurst(PlayState* play, Vec3f* refPos, f32 scale);
void func_800B2B44(PlayState* play, Actor* actor, Vec3f* pos, f32 scale);
// void func_800B2B7C(void);
void EffectSsEnIce_Spawn(PlayState* play, Vec3f* pos, f32 scale, Vec3f* velocity, Vec3f* accel, Color_RGBA8* primColor, Color_RGBA8* envColor, s32 life);
// void EffectSsFireTail_Spawn(UNK_TYPE4 uParm1, UNK_TYPE4 uParm2, Vec3f* pzParm3, UNK_TYPE4 uParm4, Vec3f* param_5, UNK_TYPE2 param_6, Color_RGBA8* param_7, Color_RGBA8* param_8, UNK_TYPE2 param_9, UNK_TYPE2 param_10, UNK_TYPE4 param_11);
// void EffectSsFireTail_SpawnFlame(UNK_TYPE1 param_1, UNK_TYPE1 param_2, UNK_TYPE1 param_3, UNK_TYPE1 param_4, UNK_TYPE2 param_5, UNK_TYPE4 param_6);
void EffectSsFireTail_SpawnFlameOnPlayer(PlayState* play, f32 scale, s16 bodyPart, f32 colorIntensity);
void EffectSsEnFire_SpawnVec3f(PlayState* play, Actor* actor, Vec3f* pos, s16 scale, s16 params, s16 flags, s16 bodyPart);
// void EffectSsEnFire_SpawnVec3s(UNK_TYPE1 param_1, UNK_TYPE1 param_2, UNK_TYPE1 param_3, UNK_TYPE1 param_4, UNK_TYPE2 param_5, UNK_TYPE2 param_6, UNK_TYPE2 param_7);
void EffectSsExtra_Spawn(PlayState* play, Vec3f* pos, Vec3f* velocity, Vec3f* accel, s16 scale, s16 scoreIndex);
void EffectSsDeadDb_Spawn(PlayState* play, Vec3f* pos, Vec3f* velocity, Vec3f* accel, Color_RGBA8* prim, Color_RGBA8* env, s16 scale, s16 scaleStep, s32 life);
void func_800B3030(PlayState* play, Vec3f* pos, Vec3f* velocity, Vec3f* accel, s16 scale, s16 scaleStep, s32 colorIndex);
void EffectSsDeadDd_Spawn(PlayState* play, Vec3f* pos, Vec3f* velocity, Vec3f* accel, Color_RGBA8* prim, Color_RGBA8* env, s16 scale, s16 scaleStep, s16 alphaStep, s32 life);
// void EffectSsDeadDs_Spawn(UNK_TYPE4 uParm1, Vec3f* pzParm2, Vec3f* pzParm3, Vec3f* pzParm4, UNK_TYPE2 param_5, UNK_TYPE2 param_6, UNK_TYPE2 param_7, UNK_TYPE4 param_8);
void func_800B31BC(PlayState* play, Vec3f* pos, s16 scale, s16 scaleStep, s16 alpha, s32 life);
void EffectSsIceSmoke_Spawn(PlayState* play, Vec3f* pos, Vec3f* velocity, Vec3f* accel, s16 scale);
void EffectSsIceBlock_Spawn(PlayState* play, Vec3f* pos, Vec3f* velocity, Vec3f* accel, s16 scale);
void FlagSet_Update(GameState* gameState);
void FlagSet_Draw(GameState* gameState);
void Overlay_LoadGameState(GameStateOverlay* overlayEntry);
void Overlay_FreeGameState(GameStateOverlay* overlayEntry);

void ActorShape_Init(ActorShape* actorShape, f32 yOffset, ActorShadowFunc shadowDraw, f32 shadowScale);
void ActorShadow_DrawCircle(Actor* actor, Lights* lights, PlayState* play);
void ActorShadow_DrawSquare(Actor* actor, Lights* lights, PlayState* play);
void ActorShadow_DrawWhiteCircle(Actor* actor, Lights* lights, PlayState* play);
void ActorShadow_DrawHorse(Actor* actor, Lights* lights, PlayState* play);

void ActorShadow_DrawFeet(Actor* actor, Lights* mapper, PlayState* play);
void Actor_SetFeetPos(Actor* actor, s32 limbIndex, s32 leftFootIndex, Vec3f* leftFootPos, s32 rightFootIndex, Vec3f* rightFootPos);
void func_800B4AEC(PlayState* play, Actor* actor, f32 y);
void func_800B4B50(Actor* actor, Lights* mapper, PlayState* play);
void Actor_GetProjectedPos(PlayState* play, Vec3f* worldPos, Vec3f* projectedPos, f32* invW);

void Target_Draw(TargetContext* targetCtx, PlayState* play);

s32 Flags_GetSwitch(PlayState* play, s32 flag);
void Flags_SetSwitch(PlayState* play, s32 flag);
void Flags_UnsetSwitch(PlayState* play, s32 flag);
s32 Flags_GetTreasure(PlayState* play, s32 flag);
void Flags_SetTreasure(PlayState* play, s32 flag);
void Flags_SetAllTreasure(PlayState* play, s32 flag);
s32 Flags_GetAllTreasure(PlayState* play);
s32 Flags_GetClear(PlayState* play, s32 roomNumber);
void Flags_SetClear(PlayState* play, s32 roomNumber);
void Flags_UnsetClear(PlayState* play, s32 roomNumber);
s32 Flags_GetClearTemp(PlayState* play, s32 roomNumber);
void Flags_SetClearTemp(PlayState* play, s32 roomNumber);
void Flags_UnsetClearTemp(PlayState* play, s32 roomNumber);
s32 Flags_GetCollectible(PlayState* play, s32 flag);
void Flags_SetCollectible(PlayState* play, s32 flag);

void TitleCard_InitBossName(GameState* gameState, TitleCardContext* titleCtx, TexturePtr texture, s16 x, s16 y, u8 width, u8 height);

s32 Actor_SetPlayerImpact(PlayState* play, PlayerImpactType type, s32 timer, f32 dist, Vec3f* pos);
f32 Actor_GetPlayerImpact(PlayState* play, f32 range, Vec3f* pos, PlayerImpactType* type);
void* Actor_AddSharedMemoryEntry(PlayState* play, s16 id, void* ptr, size_t size);
void* Actor_FreeSharedMemoryEntry(PlayState* play, s16 id);
void* Actor_FindSharedMemoryEntry(PlayState* play, s16 id);
void Actor_Kill(Actor* actor);
void Actor_SetWorldToHome(Actor* actor);
void Actor_SetFocus(Actor* actor, f32 height);
void Actor_SetWorldRotToShape(Actor* actor);
void Actor_SetShapeRotToWorld(Actor* actor);
void Actor_SetScale(Actor* actor, f32 scale);
void Actor_SetObjectDependency(PlayState* play, Actor* actor);
void Actor_SetMovementScale(s32 scale);
void Actor_UpdatePos(Actor* actor);
void Actor_UpdateVelocityWithGravity(Actor* actor);
void Actor_MoveWithGravity(Actor* actor);
void Actor_UpdateVelocityWithoutGravity(Actor* actor);
void Actor_MoveWithoutGravity(Actor* actor);
void Actor_UpdateVelocityWithoutGravityReverse(Actor* actor);
void Actor_MoveWithoutGravityReverse(Actor* actor);
void Actor_SetSpeeds(Actor* actor, f32 speed);
s16 Actor_WorldYawTowardActor(Actor* actorA, Actor* actorB);
s16 Actor_FocusYawTowardActor(Actor* actorA, Actor* actorB);
s16 Actor_WorldYawTowardPoint(Actor* actor, Vec3f* refPoint);
s16 Actor_WorldPitchTowardActor(Actor* actorA, Actor* actorB);
s16 Actor_FocusPitchTowardActor(Actor* actorA, Actor* actorB);
s16 Actor_WorldPitchTowardPoint(Actor* actor, Vec3f* refPoint);
f32 Actor_WorldDistXYZToActor(Actor* actorA, Actor* actorB);
f32 Actor_WorldDistXYZToPoint(Actor* actor, Vec3f* refPoint);
f32 Actor_WorldDistXZToActor(Actor* actorA, Actor* actorB);
f32 Actor_WorldDistXZToPoint(Actor* actor, Vec3f* refPoint);
void Actor_OffsetOfPointInActorCoords(Actor* actor, Vec3f* offset, Vec3f* point);
f32 Actor_HeightDiff(Actor* actor1, Actor* actor2);
void func_800B6F20(PlayState* play, Input* input, f32 magnitude, s16 baseYaw);
f32 Player_GetHeight(Player* player);
f32 Player_GetRunSpeedLimit(Player* player);
s32 func_800B7118(Player* player);
s32 func_800B7128(Player* player);
s32 func_800B715C(PlayState* play);
void Actor_SetCameraHorseSetting(PlayState* play, Player* player);
void Actor_MountHorse(PlayState* play, Player* player, Actor* horse);
s32 func_800B724C(PlayState* play, Actor* actor, u8 csMode);
s32 func_800B7298(PlayState* play, Actor* actor, u8 csMode);
void func_800B72F8(DynaPolyActor* dyna, f32 extraPushForce, s16 yRotation);

s32 Player_IsFacingActor(Actor* actor, s16 maxAngleDiff, PlayState* play);
s32 Actor_ActorBIsFacingActorA(Actor* actorA, Actor* actorB, s16 maxAngleDiff);
s32 Actor_IsFacingPlayer(Actor* actor, s16 angle);
s32 Actor_ActorAIsFacingActorB(Actor* actorA, Actor* actorB, s16 maxAngleDiff);
s32 Actor_IsFacingAndNearPlayer(Actor* actor, f32 range, s16 maxAngleDiff);
s32 Actor_ActorAIsFacingAndNearActorB(Actor* actorA, Actor* actorB, f32 range, s16 maxAngleDiff);

void Actor_GetSlopeDirection(CollisionPoly* floorPoly, Vec3f* slopeNormal, s16* downwardSlopeYaw);
void Actor_UpdateBgCheckInfo(PlayState* play, Actor* actor, f32 wallCheckHeight, f32 wallCheckRadius, f32 ceilingCheckHeight, u32 updBgCheckInfoFlags);
Hilite* Hilite_DrawOpa(Vec3f* object, Vec3f* eye, Vec3f* lightDir, GraphicsContext* gfxCtx);
void func_800B8050(Actor* actor, PlayState* play, s32 flag);
void func_800B8118(Actor* actor, PlayState* play, s32 flag);
PosRot* Actor_GetFocus(PosRot* dest, Actor* actor);
PosRot* Actor_GetWorld(PosRot* dest, Actor* actor);
PosRot* Actor_GetWorldPosShapeRot(PosRot* dest, Actor* actor);

s32 Target_OutsideLeashRange(Actor* actor, Player* player, s32 ignoreLeash);
s32 Actor_ProcessTalkRequest(Actor* actor, GameState* gameState);
s32 Actor_OfferTalkExchange(Actor* actor, PlayState* play, f32 xzRange, f32 yRange, PlayerItemAction exchangeItemAction);
s32 Actor_OfferTalkExchangeEquiCylinder(Actor* actor, PlayState* play, f32 radius, PlayerItemAction exchangeItemAction);
s32 Actor_OfferTalk(Actor* actor, PlayState* play, f32 radius);
s32 Actor_OfferTalkNearColChkInfoCylinder(Actor* actor, PlayState* play);
s32 Actor_TextboxIsClosing(Actor* actor, PlayState* play);
s32 Actor_ChangeFocus(Actor* actor1, PlayState* play, Actor* actor2);
PlayerItemAction Player_GetExchangeItemAction(PlayState* play);
s32 func_800B8718(Actor* actor, GameState* gameState);
s32 func_800B874C(Actor* actor, PlayState* play, f32 xzRange, f32 yRange);
s32 func_800B8804(Actor* actor, PlayState* play, f32 xzRange);
s32 func_800B886C(Actor* actor, PlayState* play);
void Actor_GetScreenPos(PlayState* play, Actor* actor, s16* x, s16* y);
s32 Actor_OnScreen(PlayState* play, Actor* actor);
s32 Actor_HasParent(Actor* actor, PlayState* play);
s32 Actor_OfferGetItem(Actor* actor, PlayState* play, GetItemId getItemId, f32 xzRange, f32 yRange);
s32 Actor_OfferGetItemNearby(Actor* actor, PlayState* play, GetItemId getItemId);
s32 Actor_OfferCarry(Actor* actor, PlayState* play);
s32 Actor_OfferGetItemFar(Actor* actor, PlayState* play, GetItemId getItemId);
s32 Actor_HasNoParent(Actor* actor, PlayState* play);
void func_800B8C20(Actor* actorA, Actor* actorB, PlayState* play);
void Actor_SetClosestSecretDistance(Actor* actor, PlayState* play);
s32 Actor_HasRider(PlayState* play, Actor* horse);
s32 Actor_SetRideActor(PlayState* play, Actor* horse, s32 mountSide);
s32 Actor_HasNoRider(PlayState* play, Actor* horse);
void func_800B8D10(PlayState* play, Actor* actor, f32 arg2, s16 arg3, f32 arg4, u32 arg5, u32 arg6);
void func_800B8D50(PlayState* play, Actor* actor, f32 arg2, s16 yaw, f32 arg4, u32 arg5);
void func_800B8D98(PlayState* play, Actor* actor, f32 arg2, s16 arg3, f32 arg4);
void func_800B8DD4(PlayState* play, Actor* actor, f32 arg2, s16 arg3, f32 arg4, u32 arg5);
void func_800B8E1C(PlayState* play, Actor* actor, f32 arg2, s16 arg3, f32 arg4);
void Player_PlaySfx(Player* player, u16 sfxId);
void Actor_PlaySfx(Actor* actor, u16 sfxId);
void Actor_PlaySfx_SurfaceBomb(PlayState* play, Actor* actor);
void Actor_PlaySfx_FlaggedCentered1(Actor* actor, u16 sfxId);
void Actor_PlaySfx_FlaggedCentered2(Actor* actor, u16 sfxId);
void Actor_PlaySfx_FlaggedCentered3(Actor* actor, u16 sfxId);
void Actor_PlaySfx_Flagged(Actor* actor, u16 sfxId);
void Actor_PlaySfx_FlaggedTimer(Actor* actor, s32 timer);
void Actor_PlaySeq_FlaggedKamaroDance(Actor* actor);
void Actor_PlaySeq_FlaggedMusicBoxHouse(Actor* actor);
s32 func_800B90AC(PlayState* play, Actor* actor, CollisionPoly* polygon, s32 bgId, Vec3f* arg4);
void Actor_DeactivateLens(PlayState* play);
void Actor_InitHalfDaysBit(ActorContext* actorCtx);
void Actor_InitContext(PlayState* play, ActorContext* actorCtx, ActorEntry* actorEntry);
void Actor_UpdateAll(PlayState* play, ActorContext* actorCtx);
s32 Actor_AddToLensActors(PlayState* play, Actor* actor);
void Actor_DrawAll(PlayState* play, ActorContext* actorCtx);
void Actor_KillAllWithMissingObject(PlayState* play, ActorContext* actorCtx);
void func_800BA798(PlayState* play, ActorContext* actorCtx);
void Actor_CleanupContext(ActorContext* actorCtx, PlayState* play);
Actor* Actor_Spawn(ActorContext* actorCtx, PlayState* play, s16 actorId, f32 posX, f32 posY, f32 posZ, s16 rotX, s16 rotY, s16 rotZ, s32 params);
Actor* Actor_SpawnAsChildAndCutscene(ActorContext* actorCtx, PlayState* play, s16 index, f32 x, f32 y, f32 z, s16 rotX, s16 rotY, s16 rotZ, s32 params, u32 csId, u32 halfDaysBits, Actor* parent);
Actor* Actor_SpawnAsChild(ActorContext* actorCtx, Actor* parent, PlayState* play, s16 actorId, f32 posX, f32 posY, f32 posZ, s16 rotX, s16 rotY, s16 rotZ, s32 params);
void Actor_SpawnTransitionActors(PlayState* play, ActorContext* actorCtx);
void Enemy_StartFinishingBlow(PlayState* play, Actor* actor);
s16 func_800BBAC0(BlinkInfo* info, s16 arg1, s16 arg2, s16 arg3);
s16 func_800BBB74(BlinkInfo* info, s16 arg1, s16 arg2, s16 arg3);
s16 func_800BBC20(BlinkInfo* info, s16 arg1, s16 arg2, s16 arg3);
void Actor_SpawnBodyParts(Actor* actor, PlayState* play, s32 partParams, Gfx** dList);
void Actor_SpawnFloorDustRing(PlayState* play, Actor* actor, Vec3f* posXZ, f32 radius, s32 countMinusOne, f32 randAccelWeight, s16 scale, s16 scaleStep, u8 useLighting);
void func_800BBFB0(PlayState* play, Vec3f* position, f32 arg2, s32 arg3, s16 arg4, s16 scaleStep, u8 arg6);
void func_800BC154(PlayState* play, ActorContext* actorCtx, Actor* actor, u8 actorCategory);
u32 Actor_GetArrowDmgFlags(s32 params);
Actor* func_800BC270(PlayState* play, Actor* actor, f32 distance, u32 dmgFlags);
Actor* func_800BC444(PlayState* play, Actor* actor, f32 distance);
s16 Actor_TestFloorInDirection(Actor* actor, PlayState* play, f32 distance, s16 angle);
s32 Actor_IsTargeted(PlayState* play, Actor* actor);
s32 Actor_OtherIsTargeted(PlayState* play, Actor* actor);
void func_800BC620(Vec3f* pos, Vec3f* scale, u8 alpha, PlayState* play);
void Actor_RequestQuake(PlayState* play, s16 y, s16 duration);
void Actor_RequestQuakeWithSpeed(PlayState* play, s16 y, s16 duration, s16 speed);
void Actor_RequestQuakeAndRumble(Actor* actor, PlayState* play, s16 quakeY, s16 quakeDuration);
void Actor_DrawDoorLock(PlayState* play, s32 frame, s32 type);
void Actor_SetColorFilter(Actor* actor, u16 colorFlag, u16 colorIntensityMax, u16 bufFlag, u16 duration);
Hilite* func_800BCBF4(Vec3f* arg0, PlayState* play);
Hilite* func_800BCC68(Vec3f* arg0, PlayState* play);
void Actor_GetClosestPosOnPath(Vec3s* points, s32 numPoints, Vec3f* srcPos, Vec3f* dstPos, s32 isPathLoop);
s32 Npc_UpdateTalking(PlayState* play, Actor* actor, s16* talkState, f32 interactRange, NpcGetTextIdFunc getTextId, NpcUpdateTalkStateFunc updateTalkState);
void Npc_TrackPoint(Actor* actor, NpcInteractInfo* interactInfo, s16 presetIndex, s16 trackingMode);
void func_800BD9E0(PlayState* play, SkelAnime* skelAnime, OverrideLimbDraw overrideLimbDraw, PostLimbDraw postLimbDraw, Actor* actor, s16 alpha);
void func_800BDAA0(PlayState* play, SkelAnime* skelAnime, OverrideLimbDraw overrideLimbDraw, PostLimbDraw postLimbDraw, Actor* actor, s16 alpha);
void Actor_ChangeAnimationByInfo(SkelAnime* skelAnime, AnimationInfo* animInfo, s32 animIndex);
void Actor_Noop(Actor* actor, PlayState* play);

void Gfx_DrawDListOpa(PlayState* play, Gfx* dlist);
void Gfx_DrawDListXlu(PlayState* play, Gfx* dlist);

Actor* Actor_FindNearby(PlayState* play, Actor* inActor, s16 actorId, u8 actorCategory, f32 distance);
s32 func_800BE184(PlayState* play, Actor* actor, f32 xzDist, s16 arg3, s16 arg4, s16 arg5);
u8 Actor_ApplyDamage(Actor* actor);
void Actor_SetDropFlag(Actor* actor, ColliderInfo* colInfo);
void Actor_SetDropFlagJntSph(Actor* actor, ColliderJntSph* jntSphere);
void func_800BE33C(Vec3f* arg0, Vec3f* arg1, Vec3s* dst, s32 arg3);
void func_800BE3D0(Actor* actor, s16 angle, Vec3s* arg2);
void func_800BE504(Actor* actor, ColliderCylinder* collider);
void func_800BE568(Actor* actor, ColliderSphere* collider);
void func_800BE5CC(Actor* actor, ColliderJntSph* collider, s32 colliderIndex);
s32 Actor_IsSmallChest(struct EnBox* chest);
void Actor_DrawDamageEffects(PlayState* play, Actor* actor, Vec3f bodyPartsPos[], s16 bodyPartsCount, f32 effectScale, f32 frozenSteamScale, f32 effectAlpha, u8 type);
void Actor_SpawnIceEffects(PlayState* play, Actor* actor, Vec3f bodyPartsPos[], s32 bodyPartsCount, s32 effectsPerBodyPart, f32 scale, f32 scaleRange);

void ActorOverlayTable_FaultClient(void* arg0, void* arg1);
uintptr_t ActorOverlayTable_FaultAddrConv(uintptr_t address, void* param);
void ActorOverlayTable_Init(void);
void ActorOverlayTable_Cleanup(void);

void DynaPolyActor_UpdateCarriedActorPos(CollisionContext* colCtx, s32 bgId, Actor* carriedActor);
void DynaPolyActor_UpdateCarriedActorRotY(CollisionContext* colCtx, s32 bgId, Actor* carriedActor);
void DynaPolyActor_AttachCarriedActor(CollisionContext* colCtx, Actor* carriedActor, s32 bgId);
u32 DynaPolyActor_TransformCarriedActor(CollisionContext* colCtx, s32 bgId, Actor* carriedActor);
void DynaPolyActor_Init(DynaPolyActor* dynaActor, s32 transformFlags);
void DynaPolyActor_LoadMesh(PlayState* play, DynaPolyActor* dynaActor, CollisionHeader* meshHeader);
void DynaPolyActor_UnsetAllInteractFlags(DynaPolyActor* dynaActor);
void DynaPolyActor_SetActorOnTop(DynaPolyActor* dynaActor);
void DynaPolyActor_SetPlayerOnTop(DynaPolyActor* dynaActor);
void DynaPoly_SetPlayerOnTop(CollisionContext* colCtx, s32 bgId);
void DynaPolyActor_SetPlayerAbove(DynaPolyActor* dynaActor);
void DynaPoly_SetPlayerAbove(CollisionContext* colCtx, s32 bgId);
void DynaPolyActor_SetActorOnSwitch(DynaPolyActor* dynaActor);
void DynaPolyActor_SetActorOnHeavySwitch(DynaPolyActor* dynaActor);
s32 DynaPolyActor_IsActorOnTop(DynaPolyActor* dynaActor);
s32 DynaPolyActor_IsPlayerOnTop(DynaPolyActor* dynaActor);
s32 DynaPolyActor_IsPlayerAbove(DynaPolyActor* dynaActor);
s32 DynaPolyActor_IsSwitchPressed(DynaPolyActor* dynaActor);
s32 DynaPolyActor_IsHeavySwitchPressed(DynaPolyActor* dynaActor);
s32 DynaPolyActor_ValidateMove(PlayState* play, DynaPolyActor* dynaActor, s16 startRadius, s16 endRadius, s16 startHeight);

Camera* Camera_Create(View* view, CollisionContext* colCtx, PlayState* play);
void Camera_Destroy(Camera* camera);
void Camera_Init(Camera* camera, View* view, CollisionContext* colCtx, PlayState* play);
void func_800DDFE0(Camera* camera);
void Camera_InitFocalActorSettings(Camera* camera, Actor* focalActor);
s32 Camera_ChangeStatus(Camera* camera, s16 status);
s32 Camera_UpdateWater(Camera* camera);
void Camera_EarthquakeDay3(Camera* camera);
s32 Camera_UpdateHotRoom(Camera* camera);
s32 Camera_SetSwordDistortion(Camera* camera);
s32 Camera_RequestGiantsMaskSetting(Camera* camera);
Vec3s* Camera_Update(Vec3s* inputDir, Camera* camera);
s32 func_800DF498(Camera* camera);
s32 Camera_ChangeModeFlags(Camera* camera, s16 mode, u8 forceChange);
s32 Camera_ChangeMode(Camera* camera, s16 mode);
s32 Camera_CheckValidMode(Camera* camera, s16 mode);
s16 Camera_ChangeSettingFlags(Camera* camera, s16 setting, s16 flags);
s32 Camera_ChangeSetting(Camera* camera, s16 setting);
s32 Camera_ChangeActorCsCamIndex(Camera* camera, s32 bgCamIndex);
Vec3s* Camera_GetInputDir(Vec3s* dst, Camera* camera);
s16 Camera_GetInputDirPitch(Camera* camera);
s16 Camera_GetInputDirYaw(Camera* camera);
Vec3s* Camera_GetCamDir(Vec3s* dst, Camera* camera);
s16 Camera_GetCamDirPitch(Camera* camera);
s16 Camera_GetCamDirYaw(Camera* camera);
s32 Camera_AddQuake(Camera* camera, s32 arg1, s16 y, s32 countdown);
s32 Camera_SetViewParam(Camera* camera, s32 viewFlag, void* param);
s32 Camera_UnsetViewFlag(Camera* camera, s16 viewFlag);
s32 Camera_OverwriteStateFlags(Camera* camera, s16 stateFlags);
s16 Camera_SetStateFlag(Camera* camera, s16 flags);
s16 Camera_UnsetStateFlag(Camera* camera, s16 flags);
s32 Camera_ChangeDoorCam(Camera* camera, Actor* doorActor, s16 bgCamIndex, f32 arg3, s16 timer1, s16 timer2, s16 timer3);
s32 Camera_Copy(Camera* dstCam, Camera* srcCam);
s32 Camera_IsDbgCamEnabled(void);
Vec3f* Camera_GetQuakeOffset(Vec3f* quakeOffset, Camera* camera);
void Camera_SetCameraData(Camera* camera, s16 setDataFlags, void* data0, void* data1, s16 data2, s16 data3);
s32 Camera_GetNegOne(void);
s16 func_800E0238(Camera* camera);
void Camera_SetFocalActor(Camera* camera, Actor* actor);
void Camera_SetTargetActor(Camera* camera, Actor* actor);
f32 Camera_GetWaterYPos(Camera* camera);
void func_800E0348(Camera* camera);

void Actor_ContinueText(PlayState* play, Actor* actor, u16 textId);
s32 Flags_GetEventChkInf(s32 flag);
void Flags_SetEventChkInf(s32 flag);
s32 Flags_GetInfTable(s32 flag);
void Flags_SetInfTable(s32 flag);
s32 Actor_TrackNone(Vec3s* headRot, Vec3s* torsoRot);
s32 Actor_TrackPoint(Actor* actor, Vec3f* target, Vec3s* headRot, Vec3s* torsoRot);
s32 Actor_TrackPlayerSetFocusHeight(PlayState* play, Actor* actor, Vec3s* headRot, Vec3s* torsoRot, f32 focusHeight);
s32 Actor_TrackPlayer(PlayState* play, Actor* actor, Vec3s* headRot, Vec3s* torsoRot, Vec3f focusPos);
void SaveContext_Init(void);

void GetItem_Draw(PlayState* play, s16 drawId);

u16 QuestHint_GetTatlTextId(PlayState* play);

void func_800F4A10(PlayState* play);
void KaleidoSetup_Update(PlayState* play);
void KaleidoSetup_Init(PlayState* play);
void KaleidoSetup_Destroy(PlayState* play);

void Font_LoadChar(PlayState* play, u16 codePointIndex, s32 offset);
void Font_LoadCharNES(PlayState* play, u8 codePointIndex, s32 offset);
void Font_LoadMessageBoxEndIcon(Font* font, u16 icon);
void Font_LoadOrderedFont(Font* font);

void* Lib_MemCpy(void* dest, void* src, size_t size);
void* Lib_MemSet(void* buffer, s32 value, size_t size);
void Lib_GetControlStickData(f32* outMagnitude, s16* outAngle, Input* input);
void Actor_ProcessInitChain(Actor* actor, InitChainEntry* ichain);
void Color_RGBA8_Copy(Color_RGBA8* dst, Color_RGBA8* src);
void Lib_PlaySfx(u16 sfxId);
void Lib_PlaySfx_2(u16 sfxId);
void Lib_PlaySfx_AtPos(Vec3f* pos, u16 sfxId);
void Lib_Vec3f_TranslateAndRotateY(Vec3f* translation, s16 rotAngle, Vec3f* src, Vec3f* dst);
void Color_RGB8_Lerp(Color_RGB8* a, Color_RGB8* b, f32 t, Color_RGB8* dst);
void Lib_Nop801004FC(void);
void* Lib_SegmentedToVirtual(void* ptr);
void* Lib_SegmentedToVirtualNull(void* ptr);
void* Lib_VirtualToPhysical(void* ptr);
void* Lib_PhysicalToVirtual(void* ptr);
void LifeMeter_Init(PlayState* play);
void LifeMeter_UpdateColors(PlayState* play);
s32 LifeMeter_SaveInterfaceHealth(PlayState* play);
s32 LifeMeter_IncreaseInterfaceHealth(PlayState* play);
s32 LifeMeter_DecreaseInterfaceHealth(PlayState* play);
void LifeMeter_Draw(PlayState* play);
void LifeMeter_UpdateSizeAndBeep(PlayState* play);
bool LifeMeter_IsCritical(void);
void Lights_PointSetInfo(LightInfo* info, s16 x, s16 y, s16 z, u8 r, u8 g, u8 b, s16 radius, s32 type);
void Lights_PointNoGlowSetInfo(LightInfo* info, s16 x, s16 y, s16 z, u8 r, u8 g, u8 b, s16 radius);
void Lights_PointGlowSetInfo(LightInfo* info, s16 x, s16 y, s16 z, u8 r, u8 g, u8 b, s16 radius);
void Lights_PointSetColorAndRadius(LightInfo* info, u8 r, u8 g, u8 b, s16 radius);
void Lights_PointSetPosition(LightInfo* info, s16 x, s16 y, s16 z);
void Lights_DirectionalSetInfo(LightInfo* info, s8 x, s8 y, s8 z, u8 r, u8 g, u8 b);
void Lights_Reset(Lights* lights, u8 r, u8 g, u8 b);
void Lights_Draw(Lights* lights, GraphicsContext* gfxCtx);
Light* Lights_FindSlot(Lights* lights);
void Lights_BindPointWithReference(Lights* lights, LightParams* params, Vec3f* pos);
void Lights_BindPoint(Lights* lights, LightParams* params, PlayState* play);
void Lights_BindDirectional(Lights* lights, LightParams* params, void* unused);
void Lights_BindAll(Lights* lights, LightNode* listHead, Vec3f* refPos, PlayState* play);
LightNode* Lights_FindBufSlot(void);
void Lights_FreeNode(LightNode* light);
void LightContext_Init(PlayState* play, LightContext* lightCtx);
void LightContext_SetAmbientColor(LightContext* lightCtx, u8 r, u8 g, u8 b);
void LightContext_SetFog(LightContext* lightCtx, u8 r, u8 g, u8 b, s16 near, s16 far);
Lights* LightContext_NewLights(LightContext* lightCtx, GraphicsContext* gfxCtx);
void LightContext_InitList(PlayState* play, LightContext* lightCtx);
void LightContext_DestroyList(PlayState* play, LightContext* lightCtx);
LightNode* LightContext_InsertLight(PlayState* play, LightContext* lightCtx, LightInfo* info);
void LightContext_RemoveLight(PlayState* play, LightContext* lightCtx, LightNode* light);
Lights* Lights_NewAndDraw(GraphicsContext* gfxCtx, u8 ambientR, u8 ambientG, u8 ambientB, u8 numLights, u8 r, u8 g, u8 b, s8 x, s8 y, s8 z);
Lights* Lights_New(GraphicsContext* gfxCtx, u8 ambientR, u8 ambientG, u8 ambientB);
void Lights_GlowCheck(PlayState* play);
void Lights_DrawGlow(PlayState* play);
void* ZeldaArena_Malloc(size_t size);
void* ZeldaArena_MallocR(size_t size);
void* ZeldaArena_Realloc(void* ptr, size_t newSize);
void ZeldaArena_Free(void* ptr);
void* ZeldaArena_Calloc(u32 num, size_t size);
void ZeldaArena_GetSizes(size_t* outMaxFree, size_t* outFree, size_t* outAlloc);
s32 ZeldaArena_Check(void);
void ZeldaArena_Init(void* start, size_t size);
void ZeldaArena_Cleanup(void);
u8 ZeldaArena_IsInitialized(void);
// void func_80102E40(void);
// void func_80102E90(void);
// void func_80102EA4(void);
void func_80102EB4(u32 param_1);
void func_80102ED0(u32 param_1);
s32 func_80102EF0(PlayState* play);
// void func_80102F9C(void);
// void func_80103090(void);
// void func_801030B4(void);
// void func_801030F4(void);
// void func_801031D0(UNK_TYPE1 param_1, UNK_TYPE1 param_2, UNK_TYPE1 param_3, UNK_TYPE1 param_4, UNK_TYPE4 param_5, UNK_TYPE4 param_6);
// void func_801039EC(void);
// void func_80103A10(void);
// void func_80103A58(void);
// void func_8010439C(void);
// void func_801045AC(void);
// void func_80104AE8(void);
// void func_80104C80(void);
void func_80104CF4(PlayState* play);
// void func_80104F34(void);
s32 func_80105294(void);
s16 func_80105318(void);
// void func_80105328(void);
// void func_8010534C(void);
void func_8010549C(PlayState* play, void* segmentAddress);
void func_8010565C(PlayState* play, u8 num, void* segmentAddress);
void func_80105818(PlayState* play, u32 uParm2, TransitionActorEntry* puParm3);
void func_80105A40(PlayState* play);
void func_80105B34(PlayState* play);
void func_80105C40(s16 arg0);
// void func_80105FE0(void);
// void func_80106408(void);
// void func_80106450(void);
// void func_801064CC(void);
s32 func_80106530(PlayState* play);
// void func_8010657C(void);
void func_80106644(PlayState* play, s16 arg1, s16 arg2, s16 arg3);
// void func_8010683C(void);
// void func_801068B4(void);
// void func_801068D8(void);
void* func_801068FC(PlayState* play, void* arg1, size_t size);
// void func_80106BEC(void);
// void func_80106D08(void);
// void func_80106D5C(UNK_TYPE1 param_1, UNK_TYPE1 param_2, UNK_TYPE1 param_3, UNK_TYPE1 param_4, UNK_TYPE4 param_5, UNK_TYPE4 param_6, UNK_TYPE4 param_7);
// void func_80107B78(UNK_TYPE1 param_1, UNK_TYPE1 param_2, UNK_TYPE1 param_3, UNK_TYPE1 param_4, UNK_TYPE4 param_5, UNK_TYPE4 param_6);
// void func_80108124(UNK_TYPE1 param_1, UNK_TYPE1 param_2, UNK_TYPE1 param_3, UNK_TYPE1 param_4, UNK_TYPE4 param_5, UNK_TYPE4 param_6);
// void func_80108558(UNK_TYPE1 param_1, UNK_TYPE1 param_2, UNK_TYPE1 param_3, UNK_TYPE1 param_4, UNK_TYPE4 param_5, UNK_TYPE4 param_6, UNK_TYPE4 param_7);
// void func_80108A10(void);
// void func_80108A64(void);
void func_80108AF8(PlayState* play);
s32 func_801090B0(s32 arg0);
s32 func_80109124(s16 arg0);
void func_801091F0(PlayState* play);
void func_80109428(PlayState* play);
// void func_801094A0(void);
// void func_801094C8(void);
// void func_801094F8(void);
// void func_80109528(void);
// void func_8010954C(void);
// void func_8010956C(void);
// void func_8010958C(void);
// void func_801095AC(void);
// void func_801095DC(void);
// void func_8010960C(void);
// void func_80109630(void);
// void func_80109650(void);
// void func_80109670(void);
// void func_801096D4(void);
// void func_80109714(void);
// void func_80109754(void);
// void func_801097C8(void);
// void func_8010983C(void);
// void func_801098A0(void);
// void func_80109908(void);
// UNK_TYPE4 func_80109964(s32 param_1);
// void func_8010997C(void);
// void func_801099AC(void);
// void func_801099DC(void);
// void func_80109A00(void);
// void func_80109A20(void);
// void func_80109A40(void);
// void func_80109A98(void);
// void func_80109AD8(void);
// void func_80109B38(void);
// void func_80109BA0(void);
// void func_80109BF4(void);
// void func_80109C38(void);
// void func_80109CBC(void);
// void func_80109D40(void);
// void func_80109DD8(void);
// void func_80109E70(void);
// void func_80109EF8(void);
// void func_80109F78(void);
s32 Map_GetDungeonOrBossAreaIndex(PlayState* play);
s32 Map_IsInDungeonOrBossArea(PlayState* play);
s32 func_8010A0A4(PlayState* play);
// void Map_GetDungeonAreaIndex(PlayState* play);
// void Map_IsInDungeonArea(PlayState* play);
// void Map_GetBossAreaIndex(PlayState* play);
// void Map_IsInBossArea(PlayState* play);
// void func_8010A238(PlayState* play);
// void func_8010A2AC(PlayState* play);
void Minimap_SavePlayerRoomInitInfo(PlayState* play);
void Map_InitRoomData(PlayState* play, s16 room);
void Map_Destroy(PlayState* play);
void Map_Init(PlayState* play);
void Minimap_Draw(PlayState* play);
void Map_Update(PlayState* play);
// void func_8010A760(void);
// void func_8010A7CC(void);
// void func_8010A814(void);
// void func_8010A85C(void);
// void func_8010A8A4(void);
// void func_8010A8EC(void);
// void func_8010A990(void);
// void func_8010AA54(void);
// void func_8010AB30(void);
// void func_8010AB94(void);
// void func_8010AC00(void);
// void func_8010AD24(void);
// void func_8010ADD4(void);
// void func_8010AE48(UNK_TYPE1 param_1, UNK_TYPE1 param_2, UNK_TYPE1 param_3, UNK_TYPE1 param_4, UNK_TYPE4 param_5);
// UNK_TYPE4 func_8010AECC(UNK_TYPE4 param_1, s32 param_2, s32* param_3);
// void func_8010AF20(void);
// void func_8010AF6C(UNK_TYPE1 param_1, UNK_TYPE1 param_2, UNK_TYPE1 param_3, UNK_TYPE1 param_4, UNK_TYPE4 param_5);
// void func_8010AF94(void);
// void func_8010AFE0(void);
// void func_8010B010(void);
// void func_8010B06C(void);
// void func_8010B0B4(void);
// void func_8010B0DC(void);
// void func_8010B108(void);
// void func_8010B140(void);
// void func_8010B180(void);
// void func_8010B1BC(void);
// void func_8010B22C(void);
// void func_8010B284(void);
// void func_8010B2C0(void);
// void func_8010B300(void);
// void func_8010B434(void);
// void func_8010B4A4(void);
// void func_8010B520(void);
// void func_8010B664(void);
// void func_8010B7A8(void);
// void func_8010B828(void);
// void func_8010B878(void);
// void func_8010B8E4(void);
// void func_8010BB0C(void);
// void func_8010BB6C(void);
// void func_8010BBCC(void);
// void func_8010BC28(void);
// void func_8010BC7C(void);
// void func_8010BD48(void);
// void func_8010BD90(void);
// void func_8010BDDC(void);
// void func_8010BE78(void);
// void func_8010BEBC(void);
// void func_8010BEF0(void);
// void func_8010BF24(void);
s32 func_8010BF58(Actor* actor, PlayState* play, void* param_3, UNK_PTR param_4, s32* param_5);
void Nmi_Init(void);
void Nmi_SetPrenmiStart(void);
// s32 Nmi_GetPrenmiHasStarted(void);
void MsgEvent_SendNullTask(void);
f32 OLib_Vec3fDist(Vec3f* a, Vec3f* b);
f32 OLib_Vec3fDistOutDiff(Vec3f* a, Vec3f* b, Vec3f* dest);
f32 OLib_Vec3fDistXZ(Vec3f* a, Vec3f* b);
f32 OLib_ClampMinDist(f32 val, f32 min);
f32 OLib_ClampMaxDist(f32 val, f32 max);
Vec3f* OLib_Vec3fDistNormalize(Vec3f* dest, Vec3f* a, Vec3f* b);
Vec3f* OLib_VecSphToVec3f(Vec3f* dest, VecSph* sph);
Vec3f* OLib_VecGeoToVec3f(Vec3f* dest, VecGeo* geo);
VecSph* OLib_Vec3fToVecSph(VecSph* dest, Vec3f* vec);
VecGeo* OLib_Vec3fToVecGeo(VecGeo* dest, Vec3f* vec);
VecSph* OLib_Vec3fDiffToVecSph(VecSph* dest, Vec3f* a, Vec3f* b);
VecGeo* OLib_Vec3fDiffToVecGeo(VecGeo* dest, Vec3f* a, Vec3f* b);
Vec3f* OLib_AddVecGeoToVec3f(Vec3f* dest, Vec3f* a, VecGeo* geo);
Vec3f* OLib_Vec3fDiffRad(Vec3f* dest, Vec3f* a, Vec3f* b);
Vec3f* OLib_Vec3fDiffDegF(Vec3f* dest, Vec3f* a, Vec3f* b);
Vec3s* OLib_Vec3fDiffBinAng(Vec3s* dest, Vec3f* a, Vec3f* b);
void OLib_Vec3fDiff(PosRot* a, Vec3f* b, Vec3f* dest, s16 mode);
void OLib_Vec3fAdd(PosRot* a, Vec3f* b, Vec3f* dest, s16 mode);

Path* Path_GetByIndex(PlayState* play, s16 index, s16 indexNone);
f32 Path_OrientAndGetDistSq(Actor* actor, Path* path, s16 waypoint, s16* yaw);
void Path_CopyLastPoint(Path* path, Vec3f* dest);

s32 func_801226E0(PlayState* play, s32 arg1);
s32 func_80122744(PlayState* play, struct_80122744_arg1* arg1, u32 arg2, Vec3s* arg3);
s32 func_80122760(PlayState* play, struct_80122744_arg1* arg1, f32 arg2);
void func_80122868(PlayState* play, Player* player);
void func_801229A0(PlayState* play, Player* player);
void func_801229EC(Actor* thisx, PlayState* play);
void func_801229FC(Player* player);
void func_80122BA4(PlayState* play, struct_80122D44_arg1* arg1, s32 arg2, s32 alpha);
void func_80122C20(PlayState* play, struct_80122D44_arg1* arg1);
void func_80122D44(PlayState* play, struct_80122D44_arg1* arg1);
u8 Player_MaskIdToItemId(s32 maskIdMinusOne);
s32 Player_GetCurMaskItemId(PlayState* play);
void func_80122F28(Player* player);
s32 func_80122F9C(PlayState* play);
s32 func_80122FCC(PlayState* play);
void func_8012300C(PlayState* play, s32 arg1);
void func_8012301C(Actor* thisx, PlayState* play2);
void func_80123140(PlayState* play, Player* player);
s32 Player_InBlockingCsMode(PlayState* play, Player* player);
s32 Player_InCsMode(PlayState* play);
s32 func_80123420(Player* player);
s32 func_80123434(Player* player);
s32 func_80123448(PlayState* play);
s32 Player_IsGoronOrDeku(Player* player);
s32 func_801234D4(PlayState* play);
s32 func_80123590(PlayState* play, Actor* actor);
ItemId Player_GetItemOnButton(PlayState* play, Player* player, EquipSlot slot);
PlayerItemAction func_80123810(PlayState* play);
PlayerModelGroup Player_ActionToModelGroup(Player* player, PlayerItemAction itemAction);
void Player_SetModelsForHoldingShield(Player* player);
void Player_SetModels(Player* player, PlayerModelGroup modelGroup);
void Player_SetModelGroup(Player* player, PlayerModelGroup modelGroup);
void func_80123C58(Player* player);
void Player_SetEquipmentData(PlayState* play, Player* player);
void Player_UpdateBottleHeld(PlayState* play, Player* player, ItemId itemId, PlayerItemAction itemAction);
void Player_Untarget(Player* player);
void func_80123DC0(Player* player);
void func_80123E90(PlayState* play, Actor* actor);
s32 func_80123F2C(PlayState* play, s32 ammo);
s32 Player_IsBurningStickInRange(PlayState* play, Vec3f* pos, f32 xzRange, f32 yRange);
u8 Player_GetStrength(void);
u8 Player_GetMask(PlayState* play);
void Player_RemoveMask(PlayState* play);
s32 Player_HasMirrorShieldEquipped(PlayState* play);
s32 Player_IsHoldingMirrorShield(PlayState* play);
s32 Player_IsHoldingHookshot(Player* player);
s32 func_801240DC(Player* player);
PlayerBButtonSword Player_BButtonSwordFromIA(Player* player, PlayerItemAction itemAction);
PlayerBButtonSword Player_GetHeldBButtonSword(Player* player);
PlayerMeleeWeapon Player_MeleeWeaponFromIA(PlayerItemAction itemAction);
PlayerMeleeWeapon Player_GetMeleeWeaponHeld(Player* player);
s32 Player_IsHoldingTwoHandedWeapon(Player* player);
PlayerBottle Player_BottleFromIA(Player* player, PlayerItemAction itemAction);
PlayerBottle Player_GetBottleHeld(Player* Player);
PlayerExplosive Player_ExplosiveFromIA(Player* player, PlayerItemAction itemAction);
PlayerExplosive Player_GetExplosiveHeld(Player* player);
PlayerSword Player_SwordFromIA(Player* player, PlayerItemAction itemAction);
s32 func_801242B4(Player* player);
s32 Player_GetEnvironmentalHazard(PlayState* play);
void Player_UpdateBunnyEars(Player* player);
void func_80124618(struct_80124618 arg0[], f32 curFrame, Vec3f* arg2);
void Player_DrawImpl(PlayState* play, void** skeleton, Vec3s* jointTable, s32 dListCount, s32 lod, PlayerTransformation playerForm, s32 boots, s32 face, OverrideLimbDrawFlex overrideLimbDraw, PostLimbDrawFlex postLimbDraw, Actor* actor);
void func_80125318(Vec3f* arg0, Vec3s* arg1);
void Player_DrawZoraShield(PlayState* play, Player* player);
void func_80125500(PlayState* play, Player* player, s32 limbIndex, Vec3f* pos, Vec3s* rot);
s32 Player_OverrideLimbDrawGameplayDefault(PlayState* play, s32 limbIndex, Gfx** dList, Vec3f* pos, Vec3s* rot, Actor* actor);
s32 Player_OverrideLimbDrawGameplayFirstPerson(PlayState* play, s32 limbIndex, Gfx** dList, Vec3f* pos, Vec3s* rot, Actor* actor);
s32 Player_OverrideLimbDrawGameplayCrawling(PlayState* play, s32 limbIndex, Gfx** dList, Vec3f* pos, Vec3s* rot, Actor* thisx);
s32 func_80126440(PlayState* play, ColliderQuad* collider, WeaponInfo* weaponInfo, Vec3f* newTip, Vec3f* newBase);
void Player_DrawGetItem(PlayState* play, Player* player);
void func_80126B8C(PlayState* play, Player* player);
s32 func_80127438(PlayState* play, Player* player, s32 currentMask);
s32 func_80128640(PlayState* play, Player* player, Gfx* dlist);
void Player_SetFeetPos(PlayState* play, Player* player, s32 limbIndex);
void Player_PostLimbDrawGameplay(PlayState* play, s32 limbIndex, Gfx** dList1, Gfx** dList2, Vec3s* rot, Actor* actor);

void Room_Noop(PlayState* play, Room* room, Input* input, s32 arg3);
void Room_Init(PlayState* play, RoomContext* roomCtx);
size_t Room_AllocateAndLoad(PlayState* play, RoomContext* roomCtx);
s32 Room_StartRoomTransition(PlayState* play, RoomContext* roomCtx, s32 index);
s32 Room_HandleLoadCallbacks(PlayState* play, RoomContext* roomCtx);
void Room_Draw(PlayState* play, Room* room, u32 flags);

void func_8012EBF8(PlayState* play, RoomContext* roomCtx);
s32 Inventory_GetBtnBItem(PlayState* play);
void Inventory_ChangeEquipment(s16 value);
u8 Inventory_DeleteEquipment(PlayState* play, s16 equipment);
void Inventory_ChangeUpgrade(s16 upgrade, u32 value);
s32 Inventory_IsMapVisible(s16 sceneId);
void Inventory_SetWorldMapCloudVisibility(s16 tingleIndex);
void Inventory_SaveDekuPlaygroundHighScore(s16 timerId);
void Inventory_IncrementSkullTokenCount(s16 sceneIndex);
s16 Inventory_GetSkullTokenCount(s16 sceneIndex);
void Inventory_SaveLotteryCodeGuess(PlayState* play);

s32 Schedule_RunScript(PlayState* play, u8* script, ScheduleOutput* output);

void SkinMatrix_Vec3fMtxFMultXYZW(MtxF* mf, Vec3f* src, Vec3f* xyzDest, f32* wDest);
void SkinMatrix_Vec3fMtxFMultXYZ(MtxF* mf, Vec3f* src, Vec3f* dest);
void SkinMatrix_MtxFMtxFMult(MtxF* mfB, MtxF* mfA, MtxF* dest);
void SkinMatrix_GetClear(MtxF** mfp);
void SkinMatrix_GetClear(MtxF** mfp);
void SkinMatrix_MtxFCopy(MtxF* src, MtxF* dest);
s32 SkinMatrix_Invert(MtxF* src, MtxF* dest);
void SkinMatrix_SetScale(MtxF* mf, f32 x, f32 y, f32 z);
void SkinMatrix_SetRotateRPY(MtxF* mf, s16 roll, s16 pitch, s16 yaw);
void SkinMatrix_SetRotateYRP(MtxF* mf, s16 yaw, s16 roll, s16 pitch);
void SkinMatrix_SetTranslate(MtxF* mf, f32 x, f32 y, f32 z);
void SkinMatrix_SetScaleRotateRPYTranslate(MtxF* mf, f32 scaleX, f32 scaleY, f32 scaleZ, s16 roll, s16 pitch, s16 yaw, f32 dx, f32 dy, f32 dz);
void SkinMatrix_SetScaleRotateYRPTranslate(MtxF* mf, f32 scaleX, f32 scaleY, f32 scaleZ, s16 yaw, s16 roll, s16 pitch, f32 dx, f32 dy, f32 dz);
void SkinMatrix_SetRotateRPYTranslate(MtxF* mf, s16 roll, s16 pitch, s16 yaw, f32 dx, f32 dy, f32 dz);
void SkinMatrix_Vec3fToVec3s(Vec3f* src, Vec3s* dest);
void SkinMatrix_Vec3sToVec3f(Vec3s* src, Vec3f* dest);
void SkinMatrix_MtxFToMtx(MtxF* src, Mtx* dest);
Mtx* SkinMatrix_MtxFToNewMtx(GraphicsContext* gfxCtx, MtxF* src);
void SkinMatrix_SetRotateAroundVec(MtxF* mf, s16 a, f32 x, f32 y, f32 z);
void SkinMatrix_SetXRotation(MtxF* mf, s16 a);
void SkinMatrix_MulXRotation(MtxF* mf, s16 a);
void SkinMatrix_SetYRotation(MtxF* mf, s16 a);
void SkinMatrix_MulYRotation(MtxF* mf, s16 a);
void SkinMatrix_SetZRotation(MtxF* mf, s16 a);

void func_80140E80(Struct_80140E80* arg0);
void func_80140EA0(Struct_80140E80* arg0);
// void func_80140EAC(UNK_TYPE1 param_1, UNK_TYPE1 param_2, UNK_TYPE1 param_3, UNK_TYPE1 param_4, UNK_TYPE4 param_5, UNK_TYPE4 param_6);
// void func_80141008(UNK_TYPE1 param_1, UNK_TYPE1 param_2, UNK_TYPE1 param_3, UNK_TYPE1 param_4, UNK_TYPE4 param_5, UNK_TYPE4 param_6, UNK_TYPE4 param_7, UNK_TYPE4 param_8, UNK_TYPE4 param_9, UNK_TYPE4 param_10);
void func_8014116C(Gfx** gfxP, u16* arg1, u16* workBuffer, s32 width, s32 height, s32 arg5);
// void func_801411B4(UNK_TYPE1 param_1, UNK_TYPE1 param_2, UNK_TYPE1 param_3, UNK_TYPE1 param_4, UNK_TYPE4 param_5, UNK_TYPE4 param_6, UNK_TYPE4 param_7, UNK_TYPE4 param_8, UNK_TYPE4 param_9, UNK_TYPE4 param_10);
// void func_80141200(UNK_TYPE1 param_1, UNK_TYPE1 param_2, UNK_TYPE1 param_3, UNK_TYPE1 param_4, UNK_TYPE4 param_5, UNK_TYPE4 param_6);
// void func_8014151C(UNK_TYPE1 param_1, UNK_TYPE1 param_2, UNK_TYPE1 param_3, UNK_TYPE1 param_4, UNK_TYPE4 param_5, UNK_TYPE4 param_6);
// void func_80141678(UNK_TYPE1 param_1, UNK_TYPE1 param_2, UNK_TYPE1 param_3, UNK_TYPE1 param_4, UNK_TYPE4 param_5);
void func_80141778(Struct_80140E80* arg0, Gfx** gfxp, void* unk_18E60, GraphicsContext* gfxCtx);

uintptr_t KaleidoManager_FaultAddrConv(uintptr_t address, void* param);
void KaleidoManager_LoadOvl(KaleidoMgrOverlay* ovl);
void KaleidoManager_ClearOvl(KaleidoMgrOverlay* ovl);
void KaleidoManager_Init(PlayState* play);
void KaleidoManager_Destroy(void);
void* KaleidoManager_GetRamAddr(void* vram);
void KaleidoScopeCall_LoadPlayer(void);
void KaleidoScopeCall_Init(PlayState* play);
void KaleidoScopeCall_Destroy(PlayState* play);
void KaleidoScopeCall_Update(PlayState* play);
void KaleidoScopeCall_Draw(PlayState* play);
void Transition_Init(TransitionContext* transitionCtx);
void Transition_Destroy(TransitionContext* transitionCtx);

void TransitionTile_Destroy(TransitionTile* this);
TransitionTile* TransitionTile_Init(TransitionTile* this, s32 cols, s32 rows);
void TransitionTile_Draw(TransitionTile* this, Gfx** gfxP);
void TransitionTile_Update(TransitionTile* this);

void TransitionFade_Start(void* thisx);
void* TransitionFade_Init(void* thisx);
void TransitionFade_Destroy(void* thisx);
void TransitionFade_Update(void* thisx, s32 updateRate);
void TransitionFade_Draw(void* thisx, Gfx** gfxP);
s32 TransitionFade_IsDone(void* thisx);
void TransitionFade_SetColor(void* thisx, u32 color);
void TransitionFade_SetType(void* thisx, s32 type);
void TransitionOverlay_ClearLoadInfo(TransitionOverlay *overlayEntry);
void TransitionOverlay_SetSegment(TransitionOverlay *overlayEntry, void* vramStart, void* vramEnd, uintptr_t vromStart, uintptr_t vromEnd);
void TransitionCircle_Start(void* thisx);
void* TransitionCircle_Init(void* thisx);
void TransitionCircle_Destroy(void* thisx);
void TransitionCircle_Update(void* thisx);
void TransitionCircle_SetColor(void* thisx, u32 color);
void TransitionCircle_SetType(void* thisx, s32 type);
void TransitionCircle_LoadAndSetTexture(Gfx** gfxp, TexturePtr texture, s32 fmt, s32 arg3, s32 masks, s32 maskt, f32 arg6);
void TransitionCircle_Draw(void* thisx, Gfx** gfxp);
s32 TransitionCircle_IsDone(void* thisx);
void* TransitionOverlay_VramToRam(TransitionOverlay *overlayEntry, void* vramAddr);
void TransitionOverlay_VramToRamArray(TransitionOverlay *overlayEntry, void** vramAddrs, s32 count);
s32  TransitionOverlay_Load(TransitionOverlay *overlayEntry);
s32  TransitionOverlay_Free(TransitionOverlay *overlayEntry);
void func_80165438(UNK_PTR param_1);
// void func_80165444(s32 param_1, UNK_TYPE4 param_2, UNK_TYPE4 param_3, UNK_TYPE4 param_4, UNK_TYPE4 param_5);

void Play_SetMotionBlurAlpha(u32 alpha);
void Play_EnableMotionBlur(u32 alpha);
void Play_DisableMotionBlur(void);
void Play_SetMotionBlurPriorityAlpha(u32 alpha);
void Play_EnableMotionBlurPriority(u32 alpha);
void Play_DisableMotionBlurPriority(void);
void Play_TriggerPictoPhoto(void);
Gfx* Play_SetFog(PlayState* this, Gfx* gfx);
void Play_Destroy(GameState* thisx);
void Play_CompressI8ToI5(void* srcI8, void* destI5, size_t size);
void Play_DecompressI5ToI8(void* srcI5, void* destI8, size_t size);
void Play_Update(PlayState* this);
void Play_Draw(PlayState* this);
void Play_Main(GameState* thisx);
s32 Play_InCsMode(PlayState* this);
f32 Play_GetFloorSurfaceImpl(PlayState* this, MtxF* mtx, CollisionPoly** poly, s32* bgId, Vec3f* pos);
void Play_GetFloorSurface(PlayState* this, MtxF* mtx, Vec3f* pos);
void* Play_LoadFile(PlayState* this, RomFile* entry);
void Play_InitEnvironment(PlayState* this, s16 skyboxId);
void Play_GetScreenPos(PlayState* this, Vec3f* worldPos, Vec3f* screenPos);
s16 Play_CreateSubCamera(PlayState* this);
s16 Play_GetActiveCamId(PlayState* this);
s32 Play_ChangeCameraStatus(PlayState* this, s16 camId, s16 status);
void Play_ClearCamera(PlayState* this, s16 camId);
Camera* Play_GetCamera(PlayState* this, s16 camId);
s32 Play_SetCameraAtEye(PlayState* this, s16 camId, Vec3f* at, Vec3f* eye);
s32 Play_SetCameraAtEyeUp(PlayState* this, s16 camId, Vec3f* at, Vec3f* eye, Vec3f* up);
s32 Play_SetCameraFov(PlayState* this, s16 camId, f32 fov);
s32 Play_SetCameraRoll(PlayState* this, s16 camId, s16 roll);
void Play_CopyCamera(PlayState* this, s16 destCamId, s16 srcCamId);
s32 func_80169A50(PlayState* this, s16 camId, Player* player, s16 setting);
s32 Play_ChangeCameraSetting(PlayState* this, s16 camId, s16 setting);
void func_80169AFC(PlayState* this, s16 camId, s16 timer);
u16 Play_GetActorCsCamSetting(PlayState* this, s32 csCamDataIndex);
Vec3s* Play_GetActorCsCamFuncData(PlayState* this, s32 csCamDataIndex);
s16 Play_GetOriginalSceneId(s16 sceneId);
void Play_SaveCycleSceneFlags(GameState* thisx);
void Play_SetRespawnData(GameState* thisx, s32 respawnMode, u16 entrance, s32 roomIndex, s32 playerParams, Vec3f* pos, s16 yaw);
void Play_SetupRespawnPoint(GameState* thisx, s32 respawnMode, s32 playerParams);
void func_80169EFC(GameState* thisx);
void func_80169F78(GameState* thisx);
void func_80169FDC(GameState* thisx);
s32 Play_CamIsNotFixed(GameState* thisx);
s32 FrameAdvance_IsEnabled(GameState* thisx);
s32 func_8016A02C(GameState* thisx, Actor* actor, s16* yaw);
s32 Play_IsUnderwater(PlayState* this, Vec3f* pos);
s32 Play_IsDebugCamEnabled(void);
void Play_AssignPlayerCsIdsFromScene(GameState* thisx, s32 spawnCsId);
void Play_FillScreen(GameState* thisx, s16 fillScreenOn, u8 red, u8 green, u8 blue, u8 alpha);
void Play_Init(GameState* thisx);

void GameAlloc_Log(GameAlloc* this);
void* GameAlloc_Malloc(GameAlloc* this, size_t size);
void GameAlloc_Free(GameAlloc* this, void* data);
void GameAlloc_Cleanup(GameAlloc* this);
void GameAlloc_Init(GameAlloc* this);
void Graph_FaultClient(void);
void Graph_InitTHGA(TwoHeadGfxArena* arena, Gfx* buffer, s32 size);
void Graph_SetNextGfxPool(GraphicsContext* gfxCtx);
GameStateOverlay* Graph_GetNextGameState(GameState* gameState);
uintptr_t Graph_FaultAddrConv(uintptr_t address, void* param);
void Graph_Init(GraphicsContext* gfxCtx);
void Graph_Destroy(GraphicsContext* gfxCtx);
void Graph_TaskSet00(GraphicsContext* gfxCtx, GameState* gameState);
void Graph_UpdateGame(GameState* gameState);
void Graph_ExecuteAndDraw(GraphicsContext* gfxCtx, GameState* gameState);
void Graph_Update(GraphicsContext* gfxCtx, GameState* gameState);
void Graph_ThreadEntry(void* arg);
Gfx* Graph_GfxPlusOne(Gfx* gfx);
Gfx* Graph_BranchDlist(Gfx* gfx, Gfx* dst);
void* Graph_DlistAlloc(Gfx** gfx, size_t size);

void Sched_SwapFramebuffer(CfbInfo* cfbInfo);
void Sched_RetraceUpdateFramebuffer(SchedContext* sched, CfbInfo* cfbInfo);
void Sched_HandleReset(SchedContext* sched);
void Sched_HandleStop(SchedContext* sched);
void Sched_HandleAudioCancel(SchedContext* sched);
void Sched_HandleGfxCancel(SchedContext* sched);
void Sched_QueueTask(SchedContext* sched, OSScTask* task);
void Sched_Yield(SchedContext* sched);
s32 Sched_Schedule(SchedContext* sched, OSScTask** spTask, OSScTask** dpTask, s32 state);
void Sched_TaskUpdateFramebuffer(SchedContext* sched, OSScTask* task);
void Sched_NotifyDone(SchedContext* sched, OSScTask* task);
void Sched_RunTask(SchedContext* sched, OSScTask* spTask, OSScTask* dpTask);
void Sched_HandleEntry(SchedContext* sched);
void Sched_HandleRetrace(SchedContext* sched);
void Sched_HandleRSPDone(SchedContext* sched);
void Sched_HandleRDPDone(SchedContext* sched);
void Sched_SendEntryMsg(SchedContext* sched);
void Sched_SendAudioCancelMsg(SchedContext* sched);
void Sched_SendGfxCancelMsg(SchedContext* sched);
void Sched_FaultClient(void* param1, void* param2);
void Sched_ThreadEntry(void* arg);
void Sched_Init(SchedContext* sched, void* stack, OSPri pri, u8 viModeType, UNK_TYPE arg4, IrqMgr* irqMgr);

void Mtx_SetTranslateScaleMtx(Mtx* mtx, f32 scaleX, f32 scaleY, f32 scaleZ, f32 translateX, f32 translateY, f32 translateZ);
void Mtx_SetRotationMtx(Mtx* mtx, s32 angle, f32 axisX, f32 axisY, f32 axisZ);
void Mtx_SetTranslationRotationScaleMtx(Mtx* mtx, f32 scaleX, f32 scaleY, f32 scaleZ, s32 angle, f32 axisX, f32 axisY, f32 axisZ,f32 translateX, f32 translateY, f32 translateZ);

void CmpDma_LoadFile(uintptr_t segmentVrom, s32 id, void* dst, size_t size);
void CmpDma_LoadAllFiles(uintptr_t segmentVrom, void* dst, size_t size);
// void Check_WriteRGBA16Pixel(u16* buffer, u32 x, u32 y, u32 value);
// void Check_WriteI4Pixel(u16* buffer, u32 x, u32 y, u32 value);
// void Check_DrawI4Texture(u16* buffer, u32 x, u32 y, u32 width, u32 height, u8* texture);
// void Check_ClearRGBA16(u16* buffer);
// void Check_DrawExpansionPakErrorMessage(void);
// void Check_DrawRegionLockErrorMessage(void);
void Check_ExpansionPak(void);
void Check_RegionIsSupported(void);

f32 Math3D_Normalize(Vec3f* vec);
s32 Math3D_PlaneVsLineSegClosestPoint(f32 planeAA, f32 planeAB, f32 planeAC, f32 planeADist, f32 planeBA, f32 planeBB, f32 planeBC, f32 planeBDist, Vec3f* linePointA, Vec3f* linePointB, Vec3f* closestPoint);
s32 func_80179798(Vec3f* param_1, Vec3f* param_2, Vec3f* param_3, Vec3f* param_4, Vec3f* param_5, Vec3f* param_6);
f32 func_80179A44(Vec3f* arg0, PosRot* arg1, Vec3f* arg2);
void func_80179B34(f32 arg0, f32 arg1, f32 arg2, f32 arg3, f32 arg4, f32 arg5, f32 arg6, f32* arg7, f32* arg8);
// UNK_TYPE4 func_80179B94(f32 fParm1, f32 fParm2, f32 fParm5, f32 param_4, f32 param_5, f32 param_6, f32 param_7, f32 param_8, Vec3f* param_9);
// void func_80179D74(UNK_TYPE1 param_1, UNK_TYPE1 param_2, UNK_TYPE1 param_3, UNK_TYPE1 param_4, UNK_TYPE4 param_5, UNK_TYPE4 param_6, UNK_TYPE4 param_7, UNK_TYPE4 param_8, UNK_TYPE4 param_9, UNK_TYPE4 param_10);
void Math3D_ScaleAndAdd(Vec3f* a, Vec3f* b, f32 scale, Vec3f* dst);
void Math3D_Lerp(Vec3f* a, Vec3f* b, f32 t, Vec3f* dst);
f32 Math3D_Parallel(Vec3f* a, Vec3f* b);
s32 Math3D_AngleBetweenVectors(Vec3f* a, Vec3f* b, f32* angle);
void func_80179F64(Vec3f* param_1, Vec3f* param_2, Vec3f* param_3);
s32 Math3D_XZBoundCheck(f32 xMin, f32 xMax, f32 zMin, f32 zMax, f32 x, f32 z);
// void func_8017A09C(UNK_TYPE1 param_1, UNK_TYPE1 param_2, UNK_TYPE1 param_3, UNK_TYPE1 param_4, UNK_TYPE4 param_5, UNK_TYPE4 param_6);
// void func_8017A1D0(UNK_TYPE1 param_1, UNK_TYPE1 param_2, UNK_TYPE1 param_3, UNK_TYPE1 param_4, UNK_TYPE4 param_5, UNK_TYPE4 param_6);
s32 func_8017A304(Vec3f* v0, Vec3f* v1, Vec3f* v2, f32 z, f32 x, f32 chkDist);
// UNK_TYPE4 func_8017A438(Vec3f* pfParm1, Vec3f* pfParm2, Vec3f* pfParm3, Vec3f* pfParm4, f32 param_5);
f32 Math3D_XZLengthSquared(f32 x, f32 z);
f32 Math3D_XZLength(f32 x, f32 z);
f32 Math3D_XZDistanceSquared(f32 x1, f32 x2, f32 z1, f32 z2);
f32 Math3D_XZDistance(f32 x1, f32 x2, f32 z1, f32 z2);
f32 Math3D_LengthSquared(Vec3f* vec);
f32 Math3D_Vec3fMagnitude(Vec3f* vec);
f32 Math3D_Vec3fDistSq(Vec3f* a, Vec3f* b);
f32 Math3D_Distance(Vec3f* a, Vec3f* b);
f32 Math3D_DistanceS(Vec3s* s, Vec3f* f);
f32 func_8017A7B8(f32* param_1, f32* param_2, f32 param_3, f32 param_4);
f32 func_8017A7F8(f32* param_1, f32* param_2, f32 param_3, f32 param_4);
f32 func_8017A838(f32* param_1, f32* param_2, f32 param_3, f32 param_4);
void Math3D_CrossProduct(Vec3f* a, Vec3f* b, Vec3f* res);
void Math3D_SurfaceNorm(Vec3f* a, Vec3f* b, Vec3f* c, Vec3f* res);
u32 Math3D_PointRelativeToCubeFaces(Vec3f* param_1, Vec3f* param_2, Vec3f* param_3);
u32 Math3D_PointRelativeToCubeEdges(Vec3f* param_1, Vec3f* param_2, Vec3f* param_3);
u32 Math3D_PointRelativeToCubeVertices(Vec3f* param_1, Vec3f* param_2, Vec3f* param_3);
s32 Math3D_LineVsCube(Vec3f* min, Vec3f* max, Vec3f* a, Vec3f* b);
// void func_8017B68C(void);
void func_8017B7F8(Vec3f* arg0, s16 arg1, f32* arg2, f32* arg3, f32* arg4);
void Math3D_UnitNormalVector(Vec3f* a, Vec3f* b, Vec3f* c, f32* normX, f32* normY, f32* normZ, f32* param_7);
f32 Math3D_SignedDistanceFromPlane(f32 normX, f32 normY, f32 normZ, f32 d, Vec3f* position);
// void func_8017B9D8(void);
f32 Math3D_UDistPlaneToPos(f32 normX, f32 normY, f32 normZ, f32 d, Vec3f* position);
f32 Math3D_DistPlaneToPos(f32 normX, f32 normY, f32 normZ, f32 d, Vec3f* position);
s32 Math3D_TriChkPointParaYDist(Vec3f* v0, Vec3f* v1, Vec3f* v2, f32 y, f32 z, f32 unk, f32 chkDist, f32 ny);
// void func_8017BD98(UNK_TYPE1 param_1, UNK_TYPE1 param_2, UNK_TYPE1 param_3, UNK_TYPE1 param_4, UNK_TYPE4 param_5, UNK_TYPE4 param_6, UNK_TYPE4 param_7);
// void func_8017BDE0(UNK_TYPE1 param_1, UNK_TYPE1 param_2, UNK_TYPE1 param_3, UNK_TYPE1 param_4, UNK_TYPE4 param_5);
s32 Math3D_TriChkPointParaYIntersectDist(Vec3f* a, Vec3f* b, Vec3f* c, f32 nx, f32 ny, f32 nz, f32 dist, f32 z, f32 x, f32* yIntersect, f32 chkDist);
s32 Math3D_TriChkPointParaYIntersectInsideTri(Vec3f* v0, Vec3f* v1, Vec3f* v2, f32 nx, f32 ny, f32 nz, f32 originDist, f32 z, f32 x, f32* yIntersect, f32 chkDist);
// void func_8017BF8C(UNK_TYPE1 param_1, UNK_TYPE1 param_2, UNK_TYPE1 param_3, UNK_TYPE1 param_4, UNK_TYPE4 param_5, UNK_TYPE4 param_6);
s32 Math3D_TriChkLineSegParaYIntersect(Vec3f* v0, Vec3f* v1, Vec3f* v2, f32 nx, f32 ny, f32 nz, f32 originDist, f32 z, f32 x, f32* yIntersect, f32 y0, f32 y1);
// void func_8017C17C(UNK_TYPE1 param_1, UNK_TYPE1 param_2, UNK_TYPE1 param_3, UNK_TYPE1 param_4, UNK_TYPE4 param_5, UNK_TYPE4 param_6, UNK_TYPE4 param_7);
// void func_8017C1F0(UNK_TYPE1 param_1, UNK_TYPE1 param_2, UNK_TYPE1 param_3, UNK_TYPE1 param_4, UNK_TYPE4 param_5, UNK_TYPE4 param_6, UNK_TYPE4 param_7, UNK_TYPE4 param_8);
s32 Math3D_TriChkPointParaYIntersectInsideTri2(Vec3f* v0, Vec3f* v1, Vec3f* v2, f32 nx, f32 ny, f32 nz, f32 originDist, f32 z, f32 x, f32* yIntersect, f32 chkDist);
s32 Math3D_TriChkPointParaXDist(Vec3f* v0, Vec3f* v1, Vec3f* v2, f32 y, f32 z, f32 unk, f32 chkDist, f32 nx);
// void func_8017C808(UNK_TYPE1 param_1, UNK_TYPE1 param_2, UNK_TYPE1 param_3, UNK_TYPE1 param_4, UNK_TYPE4 param_5, UNK_TYPE4 param_6, UNK_TYPE4 param_7);
s32 Math3D_TriChkPointParaXIntersect(Vec3f* a, Vec3f* b, Vec3f* c, f32 nx, f32 ny, f32 nz, f32 dist, f32 y, f32 z, f32* xIntersect);
// void func_8017C904(UNK_TYPE1 param_1, UNK_TYPE1 param_2, UNK_TYPE1 param_3, UNK_TYPE1 param_4, UNK_TYPE4 param_5, UNK_TYPE4 param_6);
s32 Math3D_TriChkLineSegParaXIntersect(Vec3f* v0, Vec3f* v1, Vec3f* v2, f32 nx, f32 ny, f32 nz, f32 originDist, f32 y, f32 z, f32* xIntersect, f32 x0, f32 x1);
// void func_8017CB08(UNK_TYPE1 param_1, UNK_TYPE1 param_2, UNK_TYPE1 param_3, UNK_TYPE1 param_4, UNK_TYPE4 param_5, UNK_TYPE4 param_6, UNK_TYPE4 param_7);
s32 Math3D_TriChkLineSegParaZDist(Vec3f* v0, Vec3f* v1, Vec3f* v2, f32 y, f32 z, f32 unk, f32 chkDist, f32 nz);
// void func_8017CEA8(UNK_TYPE1 param_1, UNK_TYPE1 param_2, UNK_TYPE1 param_3, UNK_TYPE1 param_4, UNK_TYPE4 param_5, UNK_TYPE4 param_6, UNK_TYPE4 param_7);
s32 Math3D_TriChkPointParaZIntersect(Vec3f* a, Vec3f* b, Vec3f* c, f32 nx, f32 ny, f32 nz, f32 dist, f32 x, f32 y, f32* zIntersect);
// void func_8017CFA4(UNK_TYPE1 param_1, UNK_TYPE1 param_2, UNK_TYPE1 param_3, UNK_TYPE1 param_4, UNK_TYPE4 param_5, UNK_TYPE4 param_6);
s32 Math3D_TriChkLineSegParaZIntersect(Vec3f* v0, Vec3f* v1, Vec3f* v2, f32 nx, f32 ny, f32 nz, f32 originDist, f32 x, f32 y, f32* zIntersect, f32 z0, f32 z1);
// void func_8017D1AC(UNK_TYPE1 param_1, UNK_TYPE1 param_2, UNK_TYPE1 param_3, UNK_TYPE1 param_4, UNK_TYPE4 param_5, UNK_TYPE4 param_6, UNK_TYPE4 param_7);
// void func_8017D220(UNK_TYPE1 param_1, UNK_TYPE1 param_2, UNK_TYPE1 param_3, UNK_TYPE1 param_4, UNK_TYPE4 param_5);
s32 Math3D_LineSegVsPlane(f32 nx, f32 ny, f32 nz, f32 originDist, Vec3f* linePointA, Vec3f* linePointB, Vec3f* intersect, s32 fromFront);
// void func_8017D404(UNK_TYPE1 param_1, UNK_TYPE1 param_2, UNK_TYPE1 param_3, UNK_TYPE1 param_4, UNK_TYPE4 param_5, UNK_TYPE4 param_6, UNK_TYPE4 param_7, UNK_TYPE4 param_8, UNK_TYPE4 param_9, UNK_TYPE4 param_10, UNK_TYPE4 param_11);
void Math3D_TriSetCoords(TriNorm* tri, Vec3f* pointA, Vec3f* pointB, Vec3f* pointC);
u32 Math3D_IsPointInSphere(Sphere16* sphere, Vec3f* point);
s32 Math3D_PointDistToLine2D(f32 arg0, f32 arg1, f32 arg2, f32 arg3, f32 arg4, f32 arg5, f32* arg6, f32* arg7, f32* arg8); // returns boolean
s32 func_8017D7C0(f32 x0, f32 y0, f32 x1, f32 y1, f32 x2, f32 y2, f32* lineLenSq);
// void func_8017D814(UNK_TYPE1 param_1, UNK_TYPE1 param_2, UNK_TYPE1 param_3, UNK_TYPE1 param_4, UNK_TYPE4 param_5);
// void func_8017D91C(UNK_TYPE1 param_1, UNK_TYPE1 param_2, UNK_TYPE1 param_3, UNK_TYPE1 param_4, UNK_TYPE4 param_5);
// void func_8017DA24(UNK_TYPE1 param_1, UNK_TYPE1 param_2, UNK_TYPE1 param_3, UNK_TYPE1 param_4, UNK_TYPE4 param_5);
s32 Math3D_LineVsSph(Sphere16* sphere, LineSegment* line);
void func_8017DD34(Sphere16* sphere, TriNorm* tri, Vec3f* pfParm3);
s32 Math3D_ColSphereTri(Sphere16* sphere, TriNorm* tri, Vec3f* uParm3);
// void func_8017E294(void);
UNK_TYPE func_8017E350(UNK_PTR, Vec3f*, Vec3f*, Vec3f*, Vec3f*);
s32 Math3D_ColCylinderTri(Cylinder16* cylinder, TriNorm* tri, Vec3f* pzParm3);
// void func_8017F1A0(void);
s32 Math3D_SphVsSph(Sphere16* sphere1, Sphere16* sphere2);
s32 Math3D_ColSphereSphereIntersect(Sphere16* sphere1, Sphere16* sphere2, f32* intersectAmount);
s32 Math3D_ColSphereSphereIntersectAndDistance(Sphere16* sphere1, Sphere16* sphere2, f32* intersectAmount, f32* dist);
s32 Math3D_ColSphereCylinderDistance(Sphere16* sphere, Cylinder16* cylinder, f32* dist);
s32 Math3D_ColSphereCylinderDistanceAndAmount(Sphere16* sphere, Cylinder16* cylinder, f32* dist, f32* intersectAmount);
s32 Math3D_ColCylinderCylinderAmount(Cylinder16* cylinder1, Cylinder16* cylinder2, f32* intersectAmount);
s32 Math3D_ColCylinderCylinderAmountAndDistance(Cylinder16* cylinder1, Cylinder16* cylinder2, f32* intersectAmount, f32* dist);
s32 Math3d_ColTriTri(TriNorm* tri1, TriNorm* tri2, Vec3f* uParm3);
s32 Math3D_XZInSphere(Sphere16* sphere, f32 x, f32 z);
s32 Math3D_XYInSphere(Sphere16* sphere, f32 x, f32 y);
s32 Math3D_YZInSphere(Sphere16* sphere, f32 y, f32 z);
// void func_8017FB1C(UNK_TYPE1 param_1, UNK_TYPE1 param_2, UNK_TYPE1 param_3, UNK_TYPE1 param_4, UNK_TYPE4 param_5, UNK_TYPE4 param_6, UNK_TYPE4 param_7, UNK_TYPE4 param_8, UNK_TYPE4 param_9, UNK_TYPE4 param_10, UNK_TYPE4 param_11);
// void func_8017FD44(void);

u64* SysUcode_GetUCodeBoot(void);
size_t SysUcode_GetUCodeBootSize(void);
u64* SysUcode_GetUCode(void);
u64* SysUcode_GetUCodeData(void);

void func_80183070(void);
// void func_801830A0(void);
// void func_801830C8(void);
// void func_801830E8(UNK_TYPE1 param_1, UNK_TYPE1 param_2, UNK_TYPE1 param_3, UNK_TYPE1 param_4, UNK_TYPE4 param_5, UNK_TYPE4 param_6, UNK_TYPE4 param_7);
// void func_80183148(void);
// void func_80183224(void);
// void func_801832B0(void);
// void func_8018332C(void);
// void func_8018340C(void);
void func_80183430(SkeletonInfo* skeletonInfo, void* arg1, void* arg2, Vec3s* arg3, Vec3s* arg4, UnkKeyframeCallback* callbacks);
void func_8018349C(UNK_PTR arg0);
void func_801834A8(SkeletonInfo* skeletonInfo, void* arg1);
// void func_80183510(void);
// void func_80183580(void);
void func_801835EC(UNK_PTR arg0, UNK_PTR arg1);
// void func_80183658(void);
// void func_801836CC(void);
// void func_8018373C(UNK_TYPE1 param_1, UNK_TYPE1 param_2, UNK_TYPE1 param_3, UNK_TYPE1 param_4, UNK_TYPE4 param_5, UNK_TYPE4 param_6, UNK_TYPE4 param_7, UNK_TYPE4 param_8, UNK_TYPE4 param_9);
// void func_801837CC(void);
// void func_80183808(UNK_TYPE1 param_1, UNK_TYPE1 param_2, UNK_TYPE1 param_3, UNK_TYPE1 param_4, UNK_TYPE4 param_5, UNK_TYPE4 param_6);
// void func_80183880(void);
// void func_80183A3C(void);
// void func_80183B08(void);
// void func_80183B68(void);
s32 func_80183DE0(SkeletonInfo* skeletonInfo);
// void func_8018410C(UNK_TYPE1 param_1, UNK_TYPE1 param_2, UNK_TYPE1 param_3, UNK_TYPE1 param_4, UNK_TYPE4 param_5, UNK_TYPE4 param_6, UNK_TYPE4 param_7);
void func_8018450C(PlayState* play, SkeletonInfo* skeleton, Mtx* mtx, OverrideKeyframeDrawScaled overrideKeyframeDraw, PostKeyframeDrawScaled postKeyframeDraw, Actor* actor);
// void func_801845A4(void);
// void func_801845C8(UNK_TYPE1 param_1, UNK_TYPE1 param_2, UNK_TYPE1 param_3, UNK_TYPE1 param_4, UNK_TYPE4 param_5);
// void func_80184638(void);
// void func_801846AC(void);
// void func_80184728(void);
// void func_801847A0(void);
// void func_80184818(void);
// void func_80184898(void);
// void func_80184914(UNK_TYPE1 param_1, UNK_TYPE1 param_2, UNK_TYPE1 param_3, UNK_TYPE1 param_4, UNK_TYPE4 param_5, UNK_TYPE4 param_6, UNK_TYPE4 param_7, UNK_TYPE4 param_8, UNK_TYPE4 param_9, UNK_TYPE4 param_10);
// void func_801849A0(void);
// void func_801849DC(void);
// void func_80184C48(void);
// void func_801850A0(UNK_TYPE1 param_1, UNK_TYPE1 param_2, UNK_TYPE1 param_3, UNK_TYPE1 param_4, UNK_TYPE4 param_5, UNK_TYPE4 param_6, UNK_TYPE4 param_7);
// void func_801853C8(UNK_TYPE1 param_1, UNK_TYPE1 param_2, UNK_TYPE1 param_3, UNK_TYPE1 param_4, UNK_TYPE4 param_5, UNK_TYPE4 param_6);
// void func_80185460(void);

s32 SysFlashrom_InitFlash(void);
s32 SysFlashrom_ReadData(void* addr, u32 pageNum, u32 pageCount);
void SysFlashrom_WriteDataAsync(u8* addr, u32 pageNum, u32 pageCount);
s32 SysFlashrom_IsBusy(void);
s32 SysFlashrom_AwaitResult(void);
void SysFlashrom_WriteDataSync(void* addr, u32 pageNum, u32 pageCount);

s32 func_80185F90(u32 arg0);

Acmd* AudioSynth_Update(Acmd* abiCmdStart, s32* numAbiCmds, s16* aiBufStart, s32 numSamplesPerFrame);

AudioTask* AudioThread_Update(void);
void AudioThread_QueueCmdF32(u32 opArgs, f32 data);
void AudioThread_QueueCmdS32(u32 opArgs, s32 data);
void AudioThread_QueueCmdS8(u32 opArgs, s8 data);
void AudioThread_QueueCmdU16(u32 opArgs, u16 data);
s32 AudioThread_ScheduleProcessCmds(void);
u32 AudioThread_GetExternalLoadQueueMsg(u32* retMsg);
u8* AudioThread_GetFontsForSequence(s32 seqId, u32* outNumFonts);
s32 func_80193C5C(void);
s32 AudioThread_ResetAudioHeap(s32 specId);
void AudioThread_PreNMIInternal(void);
s32 AudioThread_GetEnabledNotesCount(void);
u32 AudioThread_NextRandom(void);
void AudioThread_InitMesgQueues(void);

void Audio_InvalDCache(void* buf, size_t size);
void Audio_WritebackDCache(void* buf, size_t size);

void AudioPlayback_NoteDisable(Note* note);
void AudioPlayback_ProcessNotes(void);
TunedSample* AudioPlayback_GetInstrumentTunedSample(Instrument* instrument, s32 semitone);
Instrument* AudioPlayback_GetInstrumentInner(s32 fontId, s32 instId);
Drum* AudioPlayback_GetDrum(s32 fontId, s32 drumId);
SoundEffect* AudioPlayback_GetSoundEffect(s32 fontId, s32 sfxId);
s32 AudioPlayback_SetFontInstrument(s32 instrumentType, s32 fontId, s32 index, void* value);
void AudioPlayback_SeqLayerNoteDecay(SequenceLayer* layer);
void AudioPlayback_SeqLayerNoteRelease(SequenceLayer* layer);
void AudioPlayback_InitSyntheticWave(Note* note, SequenceLayer* layer);
void AudioPlayback_InitNoteLists(NotePool* pool);
void AudioPlayback_InitNoteFreeList(void);
void AudioPlayback_NotePoolClear(NotePool* pool);
void AudioPlayback_NotePoolFill(NotePool* pool, s32 count);
void AudioPlayback_AudioListRemove(AudioListItem* item);
Note* AudioPlayback_AllocNote(SequenceLayer* layer);
void AudioPlayback_NoteInitAll(void);

void AudioScript_SequenceChannelDisable(SequenceChannel* channel);
void AudioScript_SequencePlayerDisableAsFinished(SequencePlayer* seqPlayer);
void AudioScript_SequencePlayerDisable(SequencePlayer* seqPlayer);
void AudioScript_AudioListPushBack(AudioListItem* list, AudioListItem* item);
void* AudioScript_AudioListPopBack(AudioListItem* list);
void AudioScript_ProcessSequences(s32 arg0);
void AudioScript_SkipForwardSequence(SequencePlayer* seqPlayer);
void AudioScript_ResetSequencePlayer(SequencePlayer* seqPlayer);
void AudioScript_InitSequencePlayerChannels(s32 seqPlayerIndex);
void AudioScript_InitSequencePlayers(void);

void func_8019AE40(s32 param_1, s32 param_2, u32 param_3, s32 param_4);
void func_8019AEC0(UNK_PTR param_1, UNK_PTR param_2);

void AudioOcarina_SetSongStartingPos(void);
void AudioOcarina_StartAtSongStartingPos(u32 ocarinaFlags);
void AudioOcarina_StartForSongCheck(u32 ocarinaFlags, u8 ocarinaStaffPlayingPosStart);
void AudioOcarina_StartWithSongNoteLengths(u32 ocarinaFlags);
void AudioOcarina_StartDefault(u32 ocarinaFlags);
u8 func_8019B5AC(void);
void AudioOcarina_ResetAndReadInput(void);
void AudioOcarina_SetOcarinaDisableTimer(u8 unused, u8 timer);
void AudioOcarina_SetInstrument(u8 ocarinaInstrumentId);
void AudioOcarina_SetPlaybackSong(s8 songIndexPlusOne, u8 playbackState);
void AudioOcarina_SetRecordingState(u8 recordingState);
OcarinaStaff* AudioOcarina_GetRecordingStaff(void);
OcarinaStaff* AudioOcarina_GetPlayingStaff(void);
OcarinaStaff* AudioOcarina_GetPlaybackStaff(void);
void AudioOcarina_TerminaWallGenerateNotes(void);
void AudioOcarina_PlayLongScarecrowSong(void);

void Audio_Update(void);
void AudioSfx_SetProperties(u8 bankId, u8 entryIndex, u8 channelIndex);
void AudioSfx_LowerSfxSettingsReverb(Vec3f* pos, s8 isReverbLowered);
void Audio_SetBgmVolumeOff(void);
void Audio_SetBgmVolumeOn(void);
void func_801A0204(s8 seqId);
void Audio_SetMainBgmVolume(u8 targetVolume, u8 volumeFadeTimer);
void AudioSfx_SetChannelIO(Vec3f* pos, u16 sfxId, u8 ioData);
// void func_801A1290(void);
// void func_801A1348(UNK_TYPE1 param_1, UNK_TYPE1 param_2, UNK_TYPE1 param_3, UNK_TYPE1 param_4, UNK_TYPE4 param_5, UNK_TYPE4 param_6, UNK_TYPE4 param_7);
// void func_801A13BC(void);
// void func_801A153C(void);
// void func_801A17F4(void);
// void func_801A1904(void);
// void func_801A1A10(void);
// void func_801A1A8C(UNK_TYPE1 param_1, UNK_TYPE1 param_2, UNK_TYPE1 param_3, UNK_TYPE1 param_4, UNK_TYPE4 param_5, UNK_TYPE4 param_6);
void func_801A1D44(Vec3f* vec, u8 seqId, f32 arg2);
void func_801A1DB8(Vec3f* vec, u8 seqId, f32 arg2);
// void func_801A1E0C(void);
void func_801A1F00(u8 arg0, u16 seqId);
void func_801A1F88(void);
void func_801A1FB4(u8 playerIndex, Vec3f* pos, u16 seqId, f32 maxDist);
// void func_801A2090(void);
void func_801A246C(u8 param_1, u8 param_2);
void Audio_PlayMorningSceneSequence(u16 seqId, u8 dayMinusOne);
void Audio_PlaySceneSequence(u16 seqId, u8 dayMinusOne);
void Audio_SetSeqTempoAndFreq(u8 seqPlayerIndex, f32 freqTempoScale, u8 duration);
void Audio_PlaySubBgm(u16 seqId);
void Audio_StopSubBgm(void);
void Audio_PlaySequenceInCutscene(u16 seqId);
void Audio_StopSequenceInCutscene(u16 seqId);
s32 Audio_IsSequencePlaying(u8 seqId);
void Audio_PlayBgm_StorePrevBgm(u16 seqId);
void Audio_RestorePrevBgm(void);
void func_801A3000(u16 seqId, u8 ioData);
// void func_801A3038(void);
void Audio_PlayFanfare(u16 seqId);
// void func_801A312C(void);
void func_801A31EC(u16 seqId, s8 arg1, u8 arg2);
void Audio_PlaySequenceWithSeqPlayerIO(s8 seqPlayerIndex, u16 seqId, u8 fadeInDuration, s8 ioPort, u8 ioData);
void Audio_SetSequenceMode(u8 seqMode);
void Audio_UpdateEnemyBgmVolume(f32 dist);
u8 func_801A3950(s32 playerIndex, s32 isChannelIOSet);
u8 func_801A39F8(void);
void func_801A3A7C(s32 arg0);
// void func_801A3AC0(void);
void func_801A3B48(UNK_TYPE arg0);
// void func_801A3B90(void);
void func_801A3CD8(s8 param_1);
void func_801A3CF4(s8 arg0);
void func_801A3D98(s8 audioSetting);
void func_801A3E38(u8 arg0);
void func_801A3EC0(u8 arg0);
void Audio_SetCutsceneFlag(s8 flag);
void Audio_SetSpec(u32 specId);
void func_801A4058(UNK_TYPE arg0);
void func_801A41C8(s32 arg0);
void func_801A41F8(UNK_TYPE arg0);
// void func_801A42C8(void);
// void func_801A4324(void);
// void func_801A4348(void);
void Audio_PreNMI(void);
s32 func_801A46F8(void);
void Audio_SetAmbienceChannelIO(u8 channelIndexRange, u8 ioPort, u8 ioData);
void Audio_PlayAmbience(u8 ambienceId);
void Audio_Init(void);
void Audio_InitSound(void);
void Audio_ResetForAudioHeapStep3(void);
void Audio_ResetForAudioHeapStep2(void);
void Audio_ResetForAudioHeapStep1(s32 specId);

void func_801A4EB0(void);
// void func_801A4EB8(void);
void func_801A4FD8(void);
void func_801A5080(u16 arg0);
u16 func_801A5100(void);
void func_801A5118(void);
UNK_TYPE func_801A51F0(UNK_TYPE arg0);
// void func_801A5228(void);
// void func_801A5390(void);
// void func_801A53E8(UNK_TYPE1 param_1, UNK_TYPE1 param_2, UNK_TYPE1 param_3, UNK_TYPE1 param_4, UNK_TYPE2 param_5);
// void func_801A541C(void);
// void func_801A5488(void);
// void func_801A54C4(void);
// void func_801A54D0(void);
// void func_801A5680(void);
// void func_801A5808(void);
void AudioVoice_ResetData(void);
// void func_801A5A1C(void);

void AudioSfx_MuteBanks(u16 muteMask);
void AudioSfx_LowerBgmVolume(u8 channelIndex);
void AudioSfx_RestoreBgmVolume(u8 channelIndex);
void AudioSfx_PlaySfx(u16 sfxId, Vec3f* pos, u8 token, f32* freqScale, f32* volume, s8* reverbAdd);
void AudioSfx_ProcessRequest(void);
void AudioSfx_StopByBank(u8 bankId);
void AudioSfx_StopByPosAndBank(u8 bankId, Vec3f* pos);
void AudioSfx_StopByPos(Vec3f* pos);
void AudioSfx_StopByPosAndId(Vec3f* pos, u16 sfxId);
void AudioSfx_StopByTokenAndId(u8 token, u16 sfxId);
void AudioSfx_StopById(u32 sfxId);
void AudioSfx_ProcessRequests(void);
void AudioSfx_ProcessActiveSfx(void);
u8 AudioSfx_IsPlaying(u32 sfxId);
void AudioSfx_Reset(void);

void AudioSeq_StartSequence(u8 seqPlayerIndex, u8 seqId, u8 seqArgs, u16 fadeInDuration);
void AudioSeq_StopSequence(u8 seqPlayerIndex, u16 fadeOutDuration);
void AudioSeq_QueueSeqCmd(u32 cmd);
void AudioSeq_ProcessSeqCmds(void);
u16 AudioSeq_GetActiveSeqId(u8 seqPlayerIndex);
s32 AudioSeq_IsSeqCmdNotQueued(u32 cmdVal, u32 cmdMask);
void AudioSeq_SetVolumeScale(u8 seqPlayerIndex, u8 scaleIndex, u8 targetVol, u8 volFadeTimer);
void AudioSeq_UpdateActiveSequences(void);
u8 AudioSeq_UpdateAudioHeapReset(void);
u8 AudioSeq_ResetReverb(void);
void AudioSeq_ResetActiveSequences(void);
void AudioSeq_ResetActiveSequencesAndVolume(void);

void Regs_InitData(PlayState* play);

#endif
